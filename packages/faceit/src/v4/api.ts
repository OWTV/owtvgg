// tslint:disable
// biome-ignore-all lint: generated
/**
 * Data API
 * # This API provide access to FACEIT's data
 *
 * OpenAPI spec version: 4
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import * as url from "url";
import type { Configuration } from "./configuration";

const BASE_PATH = "https://open.faceit.com/data/v4".replace(/\/+$/, "");

// This is available everywhere at this point.
const portableFetch = fetch;

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
	csv: ",",
	ssv: " ",
	tsv: "\t",
	pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export type FetchAPI = (url: string, init?: any) => Promise<Response>;

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
	url: string;
	options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
	protected configuration?: Configuration;

	constructor(
		configuration?: Configuration,
		protected basePath: string = BASE_PATH,
		protected fetch: FetchAPI = portableFetch,
	) {
		if (configuration) {
			this.configuration = configuration;
			this.basePath = configuration.basePath || this.basePath;
		}
	}
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
	name = "RequiredError";
	constructor(
		public field: string,
		msg?: string,
	) {
		super(msg);
	}
}

/**
 *
 * @export
 * @interface AccessMode
 */
export interface AccessMode {
	/**
	 *
	 * @type {TypeBlock}
	 * @memberof AccessMode
	 */
	BlockVolume?: TypeBlock;
	/**
	 *
	 * @type {TypeMount}
	 * @memberof AccessMode
	 */
	MountVolume?: TypeMount;
	/**
	 *
	 * @type {Scope}
	 * @memberof AccessMode
	 */
	Scope?: Scope;
	/**
	 *
	 * @type {SharingMode}
	 * @memberof AccessMode
	 */
	Sharing?: SharingMode;
}

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
	/**
	 *
	 * @type {string}
	 * @memberof Address
	 */
	address?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Address
	 */
	city?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Address
	 */
	country?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Address
	 */
	postcode?: string;
}

/**
 *
 * @export
 * @interface AlgorithmParameters
 */
export interface AlgorithmParameters {
	/**
	 *
	 * @type {Band}
	 * @memberof AlgorithmParameters
	 */
	band?: Band;
}

/**
 *
 * @export
 * @interface Assets
 */
export interface Assets {
	/**
	 *
	 * @type {string}
	 * @memberof Assets
	 */
	color?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Assets
	 */
	icon?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Assets
	 */
	image?: string;
}

/**
 * AuthenticateOKBody authenticate o k body
 * @export
 * @interface AuthenticateOKBody
 */
export interface AuthenticateOKBody {
	/**
	 * An opaque token used to authenticate a user after a successful login
	 * @type {string}
	 * @memberof AuthenticateOKBody
	 */
	IdentityToken: string;
	/**
	 * The status of the authentication
	 * @type {string}
	 * @memberof AuthenticateOKBody
	 */
	Status: string;
}

/**
 *
 * @export
 * @interface Availability
 */
export type Availability = {};

/**
 *
 * @export
 * @interface Band
 */
export interface Band {
	/**
	 *
	 * @type {number}
	 * @memberof Band
	 */
	value?: number;
}

/**
 *
 * @export
 * @interface BirthDate
 */
export interface BirthDate {
	/**
	 *
	 * @type {number}
	 * @memberof BirthDate
	 */
	date?: number;
	/**
	 *
	 * @type {number}
	 * @memberof BirthDate
	 */
	month?: number;
	/**
	 *
	 * @type {number}
	 * @memberof BirthDate
	 */
	year?: number;
}

/**
 *
 * @export
 * @interface Brackets
 */
export interface Brackets {
	/**
	 *
	 * @type {string}
	 * @memberof Brackets
	 */
	game?: string;
	/**
	 *
	 * @type {Array<BracketsMatch>}
	 * @memberof Brackets
	 */
	matches?: Array<BracketsMatch>;
	/**
	 *
	 * @type {string}
	 * @memberof Brackets
	 */
	name?: string;
	/**
	 *
	 * @type {Array<BracketsRound>}
	 * @memberof Brackets
	 */
	rounds?: Array<BracketsRound>;
	/**
	 *
	 * @type {string}
	 * @memberof Brackets
	 */
	status?: string;
}

/**
 *
 * @export
 * @interface BracketsFaction
 */
export interface BracketsFaction {
	/**
	 *
	 * @type {string}
	 * @memberof BracketsFaction
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof BracketsFaction
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof BracketsFaction
	 */
	team_id?: string;
}

/**
 *
 * @export
 * @interface BracketsMatch
 */
export interface BracketsMatch {
	/**
	 *
	 * @type {string}
	 * @memberof BracketsMatch
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof BracketsMatch
	 */
	match_id?: string;
	/**
	 *
	 * @type {number}
	 * @memberof BracketsMatch
	 */
	position?: number;
	/**
	 *
	 * @type {MatchResult}
	 * @memberof BracketsMatch
	 */
	results?: MatchResult;
	/**
	 *
	 * @type {number}
	 * @memberof BracketsMatch
	 */
	round?: number;
	/**
	 *
	 * @type {string}
	 * @memberof BracketsMatch
	 */
	state?: string;
	/**
	 *
	 * @type {{ [key: string]: BracketsFaction; }}
	 * @memberof BracketsMatch
	 */
	teams?: { [key: string]: BracketsFaction };
}

/**
 *
 * @export
 * @interface BracketsRound
 */
export interface BracketsRound {
	/**
	 *
	 * @type {number}
	 * @memberof BracketsRound
	 */
	best_of?: number;
	/**
	 *
	 * @type {string}
	 * @memberof BracketsRound
	 */
	label?: string;
	/**
	 *
	 * @type {number}
	 * @memberof BracketsRound
	 */
	matches?: number;
	/**
	 *
	 * @type {number}
	 * @memberof BracketsRound
	 */
	round?: number;
	/**
	 *
	 * @type {number}
	 * @memberof BracketsRound
	 */
	start_time?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof BracketsRound
	 */
	starts_asap?: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof BracketsRound
	 */
	substitution_time?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof BracketsRound
	 */
	substitutions_allowed?: boolean;
}

/**
 * CapacityRange describes the minimum and maximum capacity a volume should be created with
 * @export
 * @interface CapacityRange
 */
export interface CapacityRange {
	/**
	 * LimitBytes specifies that a volume must not be bigger than this. The value of 0 indicates an unspecified maximum
	 * @type {number}
	 * @memberof CapacityRange
	 */
	LimitBytes?: number;
	/**
	 * RequiredBytes specifies that a volume must be at least this big. The value of 0 indicates an unspecified minimum.
	 * @type {number}
	 * @memberof CapacityRange
	 */
	RequiredBytes?: number;
}

/**
 *
 * @export
 * @interface Championship
 */
export interface Championship {
	/**
	 *
	 * @type {boolean}
	 * @memberof Championship
	 */
	anticheat_required?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	background_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	championship_id?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	championship_start?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	checkin_clear?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof Championship
	 */
	checkin_enabled?: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	checkin_start?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	cover_image?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	current_subscriptions?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	description?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Championship
	 */
	featured?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Championship
	 */
	full?: boolean;
	/**
	 *
	 * @type {Game}
	 * @memberof Championship
	 */
	game_data?: Game;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	game_id?: string;
	/**
	 * Deprecated: use championship_id instead
	 * @type {string}
	 * @memberof Championship
	 */
	id?: string;
	/**
	 *
	 * @type {JoinCheck}
	 * @memberof Championship
	 */
	join_checks?: JoinCheck;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	name?: string;
	/**
	 *
	 * @type {Organizer}
	 * @memberof Championship
	 */
	organizer_data?: Organizer;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {Array<Prize>}
	 * @memberof Championship
	 */
	prizes?: Array<Prize>;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	region?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	rules_id?: string;
	/**
	 *
	 * @type {{ [key: string]: ChampionshipSchedule; }}
	 * @memberof Championship
	 */
	schedule?: { [key: string]: ChampionshipSchedule };
	/**
	 *
	 * @type {ChampionshipScreening}
	 * @memberof Championship
	 */
	screening?: ChampionshipScreening;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	seeding_strategy?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	slots?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	status?: string;
	/**
	 *
	 * @type {ChampionshipStream}
	 * @memberof Championship
	 */
	stream?: ChampionshipStream;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	subscription_end?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	subscription_start?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof Championship
	 */
	subscriptions_locked?: boolean;
	/**
	 *
	 * @type {SubstitutionConfiguration}
	 * @memberof Championship
	 */
	substitution_configuration?: SubstitutionConfiguration;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	total_groups?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	total_prizes?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Championship
	 */
	total_rounds?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Championship
	 */
	type?: string;
}

/**
 *
 * @export
 * @interface ChampionshipBounds
 */
export interface ChampionshipBounds {
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipBounds
	 */
	left?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipBounds
	 */
	right?: number;
}

/**
 *
 * @export
 * @interface ChampionshipPlacement
 */
export interface ChampionshipPlacement {
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipPlacement
	 */
	id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipPlacement
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipPlacement
	 */
	type?: string;
}

/**
 *
 * @export
 * @interface ChampionshipPlacementGroup
 */
export interface ChampionshipPlacementGroup {
	/**
	 *
	 * @type {ChampionshipBounds}
	 * @memberof ChampionshipPlacementGroup
	 */
	bounds?: ChampionshipBounds;
	/**
	 *
	 * @type {Array<ChampionshipPlacement>}
	 * @memberof ChampionshipPlacementGroup
	 */
	placements?: Array<ChampionshipPlacement>;
}

/**
 *
 * @export
 * @interface ChampionshipResultList
 */
export interface ChampionshipResultList {
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipResultList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<ChampionshipPlacementGroup>}
	 * @memberof ChampionshipResultList
	 */
	items?: Array<ChampionshipPlacementGroup>;
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipResultList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface ChampionshipSchedule
 */
export interface ChampionshipSchedule {
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipSchedule
	 */
	date?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipSchedule
	 */
	status?: string;
}

/**
 *
 * @export
 * @interface ChampionshipScreening
 */
export interface ChampionshipScreening {
	/**
	 *
	 * @type {boolean}
	 * @memberof ChampionshipScreening
	 */
	enabled?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipScreening
	 */
	id?: string;
}

/**
 *
 * @export
 * @interface ChampionshipStream
 */
export interface ChampionshipStream {
	/**
	 *
	 * @type {boolean}
	 * @memberof ChampionshipStream
	 */
	active?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipStream
	 */
	platform?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipStream
	 */
	source?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipStream
	 */
	title?: string;
}

/**
 *
 * @export
 * @interface ChampionshipSubscription
 */
export interface ChampionshipSubscription {
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipSubscription
	 */
	coach?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipSubscription
	 */
	coleader?: string;
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipSubscription
	 */
	group?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipSubscription
	 */
	leader?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ChampionshipSubscription
	 */
	roster?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof ChampionshipSubscription
	 */
	status?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ChampionshipSubscription
	 */
	substitutes?: Array<string>;
	/**
	 *
	 * @type {Team}
	 * @memberof ChampionshipSubscription
	 */
	team?: Team;
}

/**
 *
 * @export
 * @interface ChampionshipSubscriptionsList
 */
export interface ChampionshipSubscriptionsList {
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipSubscriptionsList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<ChampionshipSubscription>}
	 * @memberof ChampionshipSubscriptionsList
	 */
	items?: Array<ChampionshipSubscription>;
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipSubscriptionsList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface ChampionshipsList
 */
export interface ChampionshipsList {
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipsList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Championship>}
	 * @memberof ChampionshipsList
	 */
	items?: Array<Championship>;
	/**
	 *
	 * @type {number}
	 * @memberof ChampionshipsList
	 */
	start?: number;
}

/**
 * Can be one of:  `0`: Modified (\"C\") `1`: Added (\"A\") `2`: Deleted (\"D\")
 * @export
 * @interface ChangeType
 */
export type ChangeType = {};

/**
 *
 * @export
 * @interface CheckIn
 */
export interface CheckIn {
	/**
	 *
	 * @type {number}
	 * @memberof CheckIn
	 */
	time?: number;
}

/**
 *
 * @export
 * @interface ClanSearch
 */
export interface ClanSearch {
	/**
	 * The clan's avatar url
	 * @type {string}
	 * @memberof ClanSearch
	 */
	avatar?: string;
	/**
	 * The game of the clan
	 * @type {string}
	 * @memberof ClanSearch
	 */
	game?: string;
	/**
	 * The id of the clan
	 * @type {string}
	 * @memberof ClanSearch
	 */
	id?: string;
	/**
	 * The clan's join type
	 * @type {string}
	 * @memberof ClanSearch
	 */
	join?: string;
	/**
	 * The time the clan's last match finished
	 * @type {Date}
	 * @memberof ClanSearch
	 */
	last_match_finished?: Date;
	/**
	 * The clan's matches count in the last 24 hours
	 * @type {number}
	 * @memberof ClanSearch
	 */
	matches_count_24h?: number;
	/**
	 * The clan's maximum skill level
	 * @type {number}
	 * @memberof ClanSearch
	 */
	max_skill_level?: number;
	/**
	 * The clan's members count
	 * @type {number}
	 * @memberof ClanSearch
	 */
	members_count?: number;
	/**
	 * The clan's members count in the last 24 hours
	 * @type {number}
	 * @memberof ClanSearch
	 */
	members_count_24h?: number;
	/**
	 * The clan's minimum skill level
	 * @type {number}
	 * @memberof ClanSearch
	 */
	min_skill_level?: number;
	/**
	 * The name of the clan
	 * @type {string}
	 * @memberof ClanSearch
	 */
	name?: string;
	/**
	 * The clan's organizer id
	 * @type {string}
	 * @memberof ClanSearch
	 */
	organizer_id?: string;
	/**
	 * The region of the clan
	 * @type {string}
	 * @memberof ClanSearch
	 */
	region?: string;
	/**
	 * The type of the clan
	 * @type {string}
	 * @memberof ClanSearch
	 */
	type?: string;
}

/**
 *
 * @export
 * @interface ClansSearchList
 */
export interface ClansSearchList {
	/**
	 *
	 * @type {number}
	 * @memberof ClansSearchList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<ClanSearch>}
	 * @memberof ClansSearchList
	 */
	items?: Array<ClanSearch>;
	/**
	 *
	 * @type {number}
	 * @memberof ClansSearchList
	 */
	start?: number;
}

/**
 * ClusterVolume contains options and information specific to, and only present on, Swarm CSI cluster volumes.
 * @export
 * @interface ClusterVolume
 */
export interface ClusterVolume {
	/**
	 *
	 * @type {Date}
	 * @memberof ClusterVolume
	 */
	CreatedAt?: Date;
	/**
	 * ID is the Swarm ID of the volume. Because cluster volumes are Swarm objects, they have an ID, unlike non-cluster volumes, which only have a Name. This ID can be used to refer to the cluster volume.
	 * @type {string}
	 * @memberof ClusterVolume
	 */
	ID?: string;
	/**
	 *
	 * @type {Info}
	 * @memberof ClusterVolume
	 */
	Info?: Info;
	/**
	 * PublishStatus contains the status of the volume as it pertains to its publishing on Nodes.
	 * @type {Array<PublishStatus>}
	 * @memberof ClusterVolume
	 */
	PublishStatus?: Array<PublishStatus>;
	/**
	 *
	 * @type {ClusterVolumeSpec}
	 * @memberof ClusterVolume
	 */
	Spec?: ClusterVolumeSpec;
	/**
	 *
	 * @type {Date}
	 * @memberof ClusterVolume
	 */
	UpdatedAt?: Date;
	/**
	 *
	 * @type {Version}
	 * @memberof ClusterVolume
	 */
	Version?: Version;
}

/**
 *
 * @export
 * @interface ClusterVolumeSpec
 */
export interface ClusterVolumeSpec {
	/**
	 *
	 * @type {AccessMode}
	 * @memberof ClusterVolumeSpec
	 */
	AccessMode?: AccessMode;
	/**
	 *
	 * @type {TopologyRequirement}
	 * @memberof ClusterVolumeSpec
	 */
	AccessibilityRequirements?: TopologyRequirement;
	/**
	 *
	 * @type {Availability}
	 * @memberof ClusterVolumeSpec
	 */
	Availability?: Availability;
	/**
	 *
	 * @type {CapacityRange}
	 * @memberof ClusterVolumeSpec
	 */
	CapacityRange?: CapacityRange;
	/**
	 * Group defines the volume group of this volume. Volumes belonging to the same group can be referred to by group name when creating Services. Referring to a volume by group instructs swarm to treat volumes in that group interchangeably for the purpose of scheduling. Volumes with an empty string for a group technically all belong to the same, emptystring group.
	 * @type {string}
	 * @memberof ClusterVolumeSpec
	 */
	Group?: string;
	/**
	 * Secrets defines Swarm Secrets that are passed to the CSI storage plugin when operating on this volume.
	 * @type {Array<Secret>}
	 * @memberof ClusterVolumeSpec
	 */
	Secrets?: Array<Secret>;
}

/**
 *
 * @export
 * @interface CompetitionSearch
 */
export interface CompetitionSearch {
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	competition_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	competition_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	game?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof CompetitionSearch
	 */
	number_of_members?: number;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	organizer_name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	organizer_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof CompetitionSearch
	 */
	players_checkedin?: number;
	/**
	 *
	 * @type {number}
	 * @memberof CompetitionSearch
	 */
	players_joined?: number;
	/**
	 * Tournaments
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	prize_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	region?: string;
	/**
	 * Hubs
	 * @type {number}
	 * @memberof CompetitionSearch
	 */
	slots?: number;
	/**
	 *
	 * @type {number}
	 * @memberof CompetitionSearch
	 */
	started_at?: number;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	status?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CompetitionSearch
	 */
	total_prize?: string;
}

/**
 *
 * @export
 * @interface CompetitionsSearchList
 */
export interface CompetitionsSearchList {
	/**
	 *
	 * @type {number}
	 * @memberof CompetitionsSearchList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<CompetitionSearch>}
	 * @memberof CompetitionsSearchList
	 */
	items?: Array<CompetitionSearch>;
	/**
	 *
	 * @type {number}
	 * @memberof CompetitionsSearchList
	 */
	start?: number;
}

/**
 * ContainerTopOKBody OK response to ContainerTop operation
 * @export
 * @interface ContainerTopOKBody
 */
export interface ContainerTopOKBody {
	/**
	 * Each process running in the container, where each is process is an array of values corresponding to the titles.
	 * @type {Array<Array<string>>}
	 * @memberof ContainerTopOKBody
	 */
	Processes: Array<Array<string>>;
	/**
	 * The ps column titles
	 * @type {Array<string>}
	 * @memberof ContainerTopOKBody
	 */
	Titles: Array<string>;
}

/**
 * ContainerUpdateOKBody OK response to ContainerUpdate operation
 * @export
 * @interface ContainerUpdateOKBody
 */
export interface ContainerUpdateOKBody {
	/**
	 * warnings
	 * @type {Array<string>}
	 * @memberof ContainerUpdateOKBody
	 */
	Warnings: Array<string>;
}

/**
 * Volume configuration
 * @export
 * @interface CreateOptions
 */
export interface CreateOptions {
	/**
	 *
	 * @type {ClusterVolumeSpec}
	 * @memberof CreateOptions
	 */
	ClusterVolumeSpec?: ClusterVolumeSpec;
	/**
	 * Name of the volume driver to use.
	 * @type {string}
	 * @memberof CreateOptions
	 */
	Driver?: string;
	/**
	 * A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
	 * @type {{ [key: string]: string; }}
	 * @memberof CreateOptions
	 */
	DriverOpts?: { [key: string]: string };
	/**
	 * User-defined key/value metadata.
	 * @type {{ [key: string]: string; }}
	 * @memberof CreateOptions
	 */
	Labels?: { [key: string]: string };
	/**
	 * The new volume's name. If not specified, Docker generates a name.
	 * @type {string}
	 * @memberof CreateOptions
	 */
	Name?: string;
}

/**
 * OK response to ContainerCreate operation
 * @export
 * @interface CreateResponse
 */
export interface CreateResponse {
	/**
	 * The ID of the created container
	 * @type {string}
	 * @memberof CreateResponse
	 */
	Id: string;
	/**
	 * Warnings encountered when creating the container
	 * @type {Array<string>}
	 * @memberof CreateResponse
	 */
	Warnings: Array<string>;
}

/**
 * DeleteResponse delete response
 * @export
 * @interface DeleteResponse
 */
export interface DeleteResponse {
	/**
	 * The image ID of an image that was deleted
	 * @type {string}
	 * @memberof DeleteResponse
	 */
	Deleted?: string;
	/**
	 * The image ID of an image that was untagged
	 * @type {string}
	 * @memberof DeleteResponse
	 */
	Untagged?: string;
}

/**
 * # DetailedMatchResult holds detailed match results
 * @export
 * @interface DetailedMatchResult
 */
export interface DetailedMatchResult {
	/**
	 * True if the scores should be interpreted ascending (lower score wins)
	 * @type {boolean}
	 * @memberof DetailedMatchResult
	 */
	asc_score?: boolean;
	/**
	 * The factions of the match
	 * @type {{ [key: string]: FactionResult; }}
	 * @memberof DetailedMatchResult
	 */
	factions?: { [key: string]: FactionResult };
	/**
	 * The winner faction
	 * @type {string}
	 * @memberof DetailedMatchResult
	 */
	winner?: string;
}

/**
 *
 * @export
 * @interface Division
 */
export interface Division {
	/**
	 *
	 * @type {Assets}
	 * @memberof Division
	 */
	assets?: Assets;
	/**
	 * The type of the division. Can be nested or classic. Nested means that the division has tiers, classic is without tiers.
	 * @type {string}
	 * @memberof Division
	 */
	config_type?: string;
	/**
	 *
	 * @type {LeaderboardConfig}
	 * @memberof Division
	 */
	leaderboard_config?: LeaderboardConfig;
	/**
	 * The leaderboards of the division
	 * @type {Array<string>}
	 * @memberof Division
	 */
	leaderboards?: Array<string>;
	/**
	 * Max ELO for a user to be placed in this division after placement matches
	 * @type {number}
	 * @memberof Division
	 */
	max_elo?: number;
	/**
	 * Min ELO for a user to be placed in this division after placement matches
	 * @type {number}
	 * @memberof Division
	 */
	min_elo?: number;
	/**
	 * The name of the division.
	 * @type {string}
	 * @memberof Division
	 */
	name?: string;
	/**
	 * The tiers of the division
	 * @type {Array<Tier>}
	 * @memberof Division
	 */
	tiers?: Array<Tier>;
	/**
	 * The type of the division.
	 * @type {string}
	 * @memberof Division
	 */
	type?: string;
}

/**
 *
 * @export
 * @interface EntityRanking
 */
export interface EntityRanking {
	/**
	 *
	 * @type {number}
	 * @memberof EntityRanking
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Ranking>}
	 * @memberof EntityRanking
	 */
	items?: Array<Ranking>;
	/**
	 *
	 * @type {Leaderboard}
	 * @memberof EntityRanking
	 */
	leaderboard?: Leaderboard;
	/**
	 *
	 * @type {number}
	 * @memberof EntityRanking
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
	/**
	 * The error message.
	 * @type {string}
	 * @memberof ErrorResponse
	 */
	message: string;
}

/**
 *
 * @export
 * @interface Faction
 */
export interface Faction {
	/**
	 *
	 * @type {string}
	 * @memberof Faction
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Faction
	 */
	faction_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Faction
	 */
	leader?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Faction
	 */
	name?: string;
	/**
	 *
	 * @type {Array<Roster>}
	 * @memberof Faction
	 */
	roster?: Array<Roster>;
	/**
	 *
	 * @type {any}
	 * @memberof Faction
	 */
	roster_v1?: any;
	/**
	 *
	 * @type {Stats}
	 * @memberof Faction
	 */
	stats?: Stats;
	/**
	 *
	 * @type {boolean}
	 * @memberof Faction
	 */
	substituted?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Faction
	 */
	type?: string;
}

/**
 * # FactionResult holds detailed faction score
 * @export
 * @interface FactionResult
 */
export interface FactionResult {
	/**
	 * The score of the faction.
	 * @type {number}
	 * @memberof FactionResult
	 */
	score?: number;
}

/**
 *
 * @export
 * @interface FilesystemChange
 */
export interface FilesystemChange {
	/**
	 *
	 * @type {ChangeType}
	 * @memberof FilesystemChange
	 */
	Kind: ChangeType;
	/**
	 * Path to file or directory that has changed.
	 * @type {string}
	 * @memberof FilesystemChange
	 */
	Path: string;
}

/**
 *
 * @export
 * @interface Game
 */
export interface Game {
	/**
	 *
	 * @type {GameAssets}
	 * @memberof Game
	 */
	assets?: GameAssets;
	/**
	 *
	 * @type {string}
	 * @memberof Game
	 */
	game_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Game
	 */
	long_label?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Game
	 */
	order?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Game
	 */
	parent_game_id?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Game
	 */
	platforms?: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Game
	 */
	regions?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof Game
	 */
	short_label?: string;
}

/**
 *
 * @export
 * @interface GameAssets
 */
export interface GameAssets {
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	cover?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	featured_img_l?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	featured_img_m?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	featured_img_s?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	flag_img_icon?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	flag_img_l?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	flag_img_m?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	flag_img_s?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameAssets
	 */
	landing_page?: string;
}

/**
 *
 * @export
 * @interface GameDetail
 */
export interface GameDetail {
	/**
	 *
	 * @type {number}
	 * @memberof GameDetail
	 */
	faceit_elo?: number;
	/**
	 *
	 * @type {string}
	 * @memberof GameDetail
	 */
	game_player_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameDetail
	 */
	game_player_name?: string;
	/**
	 * Deprecated: no more in use
	 * @type {string}
	 * @memberof GameDetail
	 */
	game_profile_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameDetail
	 */
	region?: string;
	/**
	 * Deprecated: no more in use
	 * @type {any}
	 * @memberof GameDetail
	 */
	regions?: any;
	/**
	 *
	 * @type {number}
	 * @memberof GameDetail
	 */
	skill_level?: number;
	/**
	 * Deprecated: use SkillLevel instead
	 * @type {string}
	 * @memberof GameDetail
	 */
	skill_level_label?: string;
}

/**
 * Here we return SkillLevel as string even if it is an int as we don't want to break the contract with devs
 * @export
 * @interface GameUserSearch
 */
export interface GameUserSearch {
	/**
	 *
	 * @type {string}
	 * @memberof GameUserSearch
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GameUserSearch
	 */
	skill_level?: string;
}

/**
 *
 * @export
 * @interface GamesList
 */
export interface GamesList {
	/**
	 *
	 * @type {number}
	 * @memberof GamesList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Game>}
	 * @memberof GamesList
	 */
	items?: Array<Game>;
	/**
	 *
	 * @type {number}
	 * @memberof GamesList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface GeoDescription
 */
export interface GeoDescription {
	/**
	 *
	 * @type {string}
	 * @memberof GeoDescription
	 */
	en?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GeoDescription
	 */
	fr?: string;
}

/**
 *
 * @export
 * @interface GeoLabel
 */
export interface GeoLabel {
	/**
	 *
	 * @type {string}
	 * @memberof GeoLabel
	 */
	en?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GeoLabel
	 */
	fr?: string;
}

/**
 *
 * @export
 * @interface GlobalRanking
 */
export interface GlobalRanking {
	/**
	 *
	 * @type {string}
	 * @memberof GlobalRanking
	 */
	country?: string;
	/**
	 *
	 * @type {number}
	 * @memberof GlobalRanking
	 */
	faceit_elo?: number;
	/**
	 *
	 * @type {number}
	 * @memberof GlobalRanking
	 */
	game_skill_level?: number;
	/**
	 *
	 * @type {string}
	 * @memberof GlobalRanking
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof GlobalRanking
	 */
	player_id?: string;
	/**
	 *
	 * @type {number}
	 * @memberof GlobalRanking
	 */
	position?: number;
}

/**
 *
 * @export
 * @interface GlobalRankingList
 */
export interface GlobalRankingList {
	/**
	 *
	 * @type {number}
	 * @memberof GlobalRankingList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<GlobalRanking>}
	 * @memberof GlobalRankingList
	 */
	items?: Array<GlobalRanking>;
	/**
	 *
	 * @type {number}
	 * @memberof GlobalRankingList
	 */
	start?: number;
}

/**
 * GraphDriverData Information about the storage driver used to store the container's and image's filesystem.
 * @export
 * @interface GraphDriverData
 */
export interface GraphDriverData {
	/**
	 * Low-level storage metadata, provided as key/value pairs.  This information is driver-specific, and depends on the storage-driver in use, and should be used for informational purposes only.
	 * @type {{ [key: string]: string; }}
	 * @memberof GraphDriverData
	 */
	Data: { [key: string]: string };
	/**
	 * Name of the storage driver.
	 * @type {string}
	 * @memberof GraphDriverData
	 */
	Name: string;
}

/**
 *
 * @export
 * @interface HistoryFaction
 */
export interface HistoryFaction {
	/**
	 *
	 * @type {string}
	 * @memberof HistoryFaction
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HistoryFaction
	 */
	nickname?: string;
	/**
	 *
	 * @type {Array<MatchHistoryPlayer>}
	 * @memberof HistoryFaction
	 */
	players?: Array<MatchHistoryPlayer>;
	/**
	 *
	 * @type {string}
	 * @memberof HistoryFaction
	 */
	team_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HistoryFaction
	 */
	type?: string;
}

/**
 * HistoryResponseItem individual image layer information in response to ImageHistory operation
 * @export
 * @interface HistoryResponseItem
 */
export interface HistoryResponseItem {
	/**
	 * comment
	 * @type {string}
	 * @memberof HistoryResponseItem
	 */
	Comment: string;
	/**
	 * created
	 * @type {number}
	 * @memberof HistoryResponseItem
	 */
	Created: number;
	/**
	 * created by
	 * @type {string}
	 * @memberof HistoryResponseItem
	 */
	CreatedBy: string;
	/**
	 * Id
	 * @type {string}
	 * @memberof HistoryResponseItem
	 */
	Id: string;
	/**
	 * size
	 * @type {number}
	 * @memberof HistoryResponseItem
	 */
	Size: number;
	/**
	 * tags
	 * @type {Array<string>}
	 * @memberof HistoryResponseItem
	 */
	Tags: Array<string>;
}

/**
 *
 * @export
 * @interface Hub
 */
export interface Hub {
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	background_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	chat_room_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	cover_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	description?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {Game}
	 * @memberof Hub
	 */
	game_data?: Game;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	game_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	hub_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	join_permission?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Hub
	 */
	max_skill_level?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Hub
	 */
	min_skill_level?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	name?: string;
	/**
	 *
	 * @type {Organizer}
	 * @memberof Hub
	 */
	organizer_data?: Organizer;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Hub
	 */
	players_joined?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	region?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Hub
	 */
	rule_id?: string;
}

/**
 *
 * @export
 * @interface HubMembers
 */
export interface HubMembers {
	/**
	 *
	 * @type {number}
	 * @memberof HubMembers
	 */
	end?: number;
	/**
	 *
	 * @type {Array<HubUser>}
	 * @memberof HubMembers
	 */
	items?: Array<HubUser>;
	/**
	 *
	 * @type {number}
	 * @memberof HubMembers
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface HubSmall
 */
export interface HubSmall {
	/**
	 *
	 * @type {string}
	 * @memberof HubSmall
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HubSmall
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HubSmall
	 */
	game_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HubSmall
	 */
	hub_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HubSmall
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HubSmall
	 */
	organizer_id?: string;
}

/**
 *
 * @export
 * @interface HubStats
 */
export interface HubStats {
	/**
	 *
	 * @type {string}
	 * @memberof HubStats
	 */
	game_id?: string;
	/**
	 *
	 * @type {Array<StatsCompetitionPlayer>}
	 * @memberof HubStats
	 */
	players?: Array<StatsCompetitionPlayer>;
}

/**
 *
 * @export
 * @interface HubUser
 */
export interface HubUser {
	/**
	 *
	 * @type {string}
	 * @memberof HubUser
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HubUser
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof HubUser
	 */
	nickname?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof HubUser
	 */
	roles?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof HubUser
	 */
	user_id?: string;
}

/**
 *
 * @export
 * @interface HubsList
 */
export interface HubsList {
	/**
	 *
	 * @type {number}
	 * @memberof HubsList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Hub>}
	 * @memberof HubsList
	 */
	items?: Array<Hub>;
	/**
	 *
	 * @type {number}
	 * @memberof HubsList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface HubsSmallList
 */
export interface HubsSmallList {
	/**
	 *
	 * @type {number}
	 * @memberof HubsSmallList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<HubSmall>}
	 * @memberof HubsSmallList
	 */
	items?: Array<HubSmall>;
	/**
	 *
	 * @type {number}
	 * @memberof HubsSmallList
	 */
	start?: number;
}

/**
 * IDResponse Response to an API call that returns just an Id
 * @export
 * @interface IdResponse
 */
export interface IdResponse {
	/**
	 * The id of the newly created object.
	 * @type {string}
	 * @memberof IdResponse
	 */
	Id: string;
}

/**
 * Info contains information about the Volume as a whole as provided by the CSI storage plugin.
 * @export
 * @interface Info
 */
export interface Info {
	/**
	 * AccessibleTopolgoy is the topology this volume is actually accessible from.
	 * @type {Array<Topology>}
	 * @memberof Info
	 */
	AccessibleTopology?: Array<Topology>;
	/**
	 * CapacityBytes is the capacity of the volume in bytes. A value of 0 indicates that the capacity is unknown.
	 * @type {number}
	 * @memberof Info
	 */
	CapacityBytes?: number;
	/**
	 * VolumeContext is the context originating from the CSI storage plugin when the Volume is created.
	 * @type {{ [key: string]: string; }}
	 * @memberof Info
	 */
	VolumeContext?: { [key: string]: string };
	/**
	 * VolumeID is the ID of the Volume as seen by the CSI storage plugin. This is distinct from the Volume's Swarm ID, which is the ID used by all of the Docker Engine to refer to the Volume. If this field is blank, then the Volume has not been successfully created yet.
	 * @type {string}
	 * @memberof Info
	 */
	VolumeID?: string;
}

/**
 *
 * @export
 * @interface Item
 */
export interface Item {
	/**
	 *
	 * @type {string}
	 * @memberof Item
	 */
	category?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Item
	 */
	country_blacklist?: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Item
	 */
	country_whitelist?: Array<string>;
	/**
	 *
	 * @type {Date}
	 * @memberof Item
	 */
	created_at?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof Item
	 */
	created_by?: string;
	/**
	 * ExternalId refers to the ID of the item in a third-party shop
	 * @type {string}
	 * @memberof Item
	 */
	external_id?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Item
	 */
	games?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof Item
	 */
	id?: string;
	/**
	 *
	 * @type {ItemMedia}
	 * @memberof Item
	 */
	media?: ItemMedia;
	/**
	 *
	 * @type {string}
	 * @memberof Item
	 */
	name?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Item
	 */
	_new?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Item
	 */
	order_type?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Item
	 */
	platforms?: Array<string>;
	/**
	 *
	 * @type {number}
	 * @memberof Item
	 */
	price?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof Item
	 */
	published?: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof Item
	 */
	quantity?: number;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Item
	 */
	sizes?: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Item
	 */
	tags?: Array<string>;
	/**
	 *
	 * @type {boolean}
	 * @memberof Item
	 */
	unlimited?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Item
	 */
	url?: string;
}

/**
 *
 * @export
 * @interface ItemList
 */
export interface ItemList {
	/**
	 *
	 * @type {number}
	 * @memberof ItemList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Item>}
	 * @memberof ItemList
	 */
	items?: Array<Item>;
	/**
	 *
	 * @type {number}
	 * @memberof ItemList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface ItemMedia
 */
export interface ItemMedia {
	/**
	 *
	 * @type {string}
	 * @memberof ItemMedia
	 */
	avatar_full?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ItemMedia
	 */
	avatar_medium?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ItemMedia
	 */
	avatar_small?: string;
}

/**
 *
 * @export
 * @interface JoinCheck
 */
export interface JoinCheck {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof JoinCheck
	 */
	allowed_team_types?: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof JoinCheck
	 */
	blacklist_geo_countries?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof JoinCheck
	 */
	join_policy?: string;
	/**
	 *
	 * @type {number}
	 * @memberof JoinCheck
	 */
	max_skill_level?: number;
	/**
	 *
	 * @type {string}
	 * @memberof JoinCheck
	 */
	membership_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof JoinCheck
	 */
	min_skill_level?: number;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof JoinCheck
	 */
	whitelist_geo_countries?: Array<string>;
	/**
	 *
	 * @type {number}
	 * @memberof JoinCheck
	 */
	whitelist_geo_countries_min_players?: number;
}

/**
 *
 * @export
 * @interface JoinType
 */
export interface JoinType {
	/**
	 *
	 * @type {number}
	 * @memberof JoinType
	 */
	maxParty?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof JoinType
	 */
	party?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof JoinType
	 */
	premade?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof JoinType
	 */
	solo?: boolean;
}

/**
 *
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	competition_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	competition_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	end_date?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	game_id?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	group?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	leaderboard_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	leaderboard_mode?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	leaderboard_name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	leaderboard_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	min_matches?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	points_per_draw?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	points_per_loss?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	points_per_win?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	points_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	ranking_boost?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	ranking_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	region?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	round?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	season?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	start_date?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Leaderboard
	 */
	starting_points?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Leaderboard
	 */
	status?: string;
}

/**
 *
 * @export
 * @interface LeaderboardConfig
 */
export interface LeaderboardConfig {
	/**
	 * Max players in the leaderboard.
	 * @type {number}
	 * @memberof LeaderboardConfig
	 */
	max_players?: number;
	/**
	 * User will lose this amount of points if they lose a match
	 * @type {number}
	 * @memberof LeaderboardConfig
	 */
	points_per_loss?: number;
	/**
	 * User will gain this amount of points if they win a match. When not configured, it's using the global value which is 3
	 * @type {number}
	 * @memberof LeaderboardConfig
	 */
	points_per_win?: number;
	/**
	 *
	 * @type {Promotion}
	 * @memberof LeaderboardConfig
	 */
	promotion?: Promotion;
	/**
	 *
	 * @type {Relegation}
	 * @memberof LeaderboardConfig
	 */
	relegation?: Relegation;
	/**
	 * Starting points for a player.
	 * @type {number}
	 * @memberof LeaderboardConfig
	 */
	starting_points?: number;
}

/**
 *
 * @export
 * @interface LeaderboardsList
 */
export interface LeaderboardsList {
	/**
	 *
	 * @type {number}
	 * @memberof LeaderboardsList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Leaderboard>}
	 * @memberof LeaderboardsList
	 */
	items?: Array<Leaderboard>;
	/**
	 *
	 * @type {number}
	 * @memberof LeaderboardsList
	 */
	start?: number;
}

/**
 * The League holds league information.
 * @export
 * @interface League
 */
export interface League {
	/**
	 * The divisions of the league.
	 * @type {Array<Division>}
	 * @memberof League
	 */
	divisions?: Array<Division>;
	/**
	 * The game of the league.
	 * @type {string}
	 * @memberof League
	 */
	game?: string;
	/**
	 * The id of the league.
	 * @type {string}
	 * @memberof League
	 */
	id?: string;
	/**
	 * The minimum matches of the league.
	 * @type {number}
	 * @memberof League
	 */
	min_matches?: number;
	/**
	 * The region of the league.
	 * @type {string}
	 * @memberof League
	 */
	region?: string;
	/**
	 *
	 * @type {Season}
	 * @memberof League
	 */
	season?: Season;
}

/**
 * Volume list response
 * @export
 * @interface ListResponse
 */
export interface ListResponse {
	/**
	 * List of volumes
	 * @type {Array<Volume>}
	 * @memberof ListResponse
	 */
	Volumes?: Array<Volume>;
	/**
	 * Warnings that occurred when fetching the list of volumes.
	 * @type {Array<string>}
	 * @memberof ListResponse
	 */
	Warnings?: Array<string>;
}

/**
 *
 * @export
 * @interface Match
 */
export interface Match {
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	best_of?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	broadcast_start_time?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	broadcast_start_time_label?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Match
	 */
	calculate_elo?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	chat_room_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	competition_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	competition_name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	competition_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	configured_at?: number;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Match
	 */
	demo_url?: Array<string>;
	/**
	 *
	 * @type {Array<DetailedMatchResult>}
	 * @memberof Match
	 */
	detailed_results?: Array<DetailedMatchResult>;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	finished_at?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	game?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	group?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	match_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	region?: string;
	/**
	 *
	 * @type {MatchResult}
	 * @memberof Match
	 */
	results?: MatchResult;
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	round?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	scheduled_at?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	started_at?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Match
	 */
	status?: string;
	/**
	 *
	 * @type {{ [key: string]: Faction; }}
	 * @memberof Match
	 */
	teams?: { [key: string]: Faction };
	/**
	 *
	 * @type {number}
	 * @memberof Match
	 */
	version?: number;
	/**
	 *
	 * @type {any}
	 * @memberof Match
	 */
	voting?: any;
}

/**
 *
 * @export
 * @interface MatchHistory
 */
export interface MatchHistory {
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	competition_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	competition_name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	competition_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistory
	 */
	finished_at?: number;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	game_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	game_mode?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	match_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	match_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistory
	 */
	max_players?: number;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof MatchHistory
	 */
	playing_players?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	region?: string;
	/**
	 *
	 * @type {MatchResult}
	 * @memberof MatchHistory
	 */
	results?: MatchResult;
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistory
	 */
	started_at?: number;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistory
	 */
	status?: string;
	/**
	 *
	 * @type {{ [key: string]: HistoryFaction; }}
	 * @memberof MatchHistory
	 */
	teams?: { [key: string]: HistoryFaction };
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistory
	 */
	teams_size?: number;
}

/**
 *
 * @export
 * @interface MatchHistoryList
 */
export interface MatchHistoryList {
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistoryList
	 */
	end?: number;
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistoryList
	 */
	from?: number;
	/**
	 *
	 * @type {Array<MatchHistory>}
	 * @memberof MatchHistoryList
	 */
	items?: Array<MatchHistory>;
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistoryList
	 */
	start?: number;
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistoryList
	 */
	to?: number;
}

/**
 *
 * @export
 * @interface MatchHistoryPlayer
 */
export interface MatchHistoryPlayer {
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistoryPlayer
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistoryPlayer
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistoryPlayer
	 */
	game_player_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistoryPlayer
	 */
	game_player_name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistoryPlayer
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchHistoryPlayer
	 */
	player_id?: string;
	/**
	 *
	 * @type {number}
	 * @memberof MatchHistoryPlayer
	 */
	skill_level?: number;
}

/**
 *
 * @export
 * @interface MatchList
 */
export interface MatchList {
	/**
	 *
	 * @type {number}
	 * @memberof MatchList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Match>}
	 * @memberof MatchList
	 */
	items?: Array<Match>;
	/**
	 *
	 * @type {number}
	 * @memberof MatchList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface MatchResult
 */
export interface MatchResult {
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof MatchResult
	 */
	score?: { [key: string]: number };
	/**
	 *
	 * @type {string}
	 * @memberof MatchResult
	 */
	winner?: string;
}

/**
 *
 * @export
 * @interface MatchStats
 */
export interface MatchStats {
	/**
	 *
	 * @type {Array<RoundStats>}
	 * @memberof MatchStats
	 */
	rounds?: Array<RoundStats>;
}

/**
 * Matchmaking A detailed representation of a matchmaking
 * @export
 * @interface Matchmaking
 */
export interface Matchmaking {
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	game?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	icon?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	league_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	long_description?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	name?: string;
	/**
	 *
	 * @type {Array<MatchmakingQueue>}
	 * @memberof Matchmaking
	 */
	queues?: Array<MatchmakingQueue>;
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	region?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Matchmaking
	 */
	short_description?: string;
}

/**
 * MatchmakingList A list of matchmaking objects
 * @export
 * @interface MatchmakingList
 */
export interface MatchmakingList {
	/**
	 *
	 * @type {number}
	 * @memberof MatchmakingList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<MatchmakingSlim>}
	 * @memberof MatchmakingList
	 */
	items?: Array<MatchmakingSlim>;
	/**
	 *
	 * @type {number}
	 * @memberof MatchmakingList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface MatchmakingQueue
 */
export interface MatchmakingQueue {
	/**
	 *
	 * @type {string}
	 * @memberof MatchmakingQueue
	 */
	id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchmakingQueue
	 */
	name?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof MatchmakingQueue
	 */
	open?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof MatchmakingQueue
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof MatchmakingQueue
	 */
	paused?: boolean;
}

/**
 * MatchmakingSlim A slim representation of a matchmaking
 * @export
 * @interface MatchmakingSlim
 */
export interface MatchmakingSlim {
	/**
	 *
	 * @type {string}
	 * @memberof MatchmakingSlim
	 */
	game?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof MatchmakingSlim
	 */
	has_league?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof MatchmakingSlim
	 */
	id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchmakingSlim
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof MatchmakingSlim
	 */
	region?: string;
}

/**
 *
 * @export
 * @interface Meta
 */
export interface Meta {
	/**
	 *
	 * @type {Date}
	 * @memberof Meta
	 */
	CreatedAt?: Date;
	/**
	 *
	 * @type {Date}
	 * @memberof Meta
	 */
	UpdatedAt?: Date;
	/**
	 *
	 * @type {Version}
	 * @memberof Meta
	 */
	Version?: Version;
}

/**
 *
 * @export
 * @interface Order
 */
export interface Order {
	/**
	 *
	 * @type {Date}
	 * @memberof Order
	 */
	created_at?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	game?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	id?: string;
	/**
	 *
	 * @type {OrderItem}
	 * @memberof Order
	 */
	item?: OrderItem;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	status?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof Order
	 */
	updated_at?: Date;
	/**
	 *
	 * @type {OrderUser}
	 * @memberof Order
	 */
	user?: OrderUser;
}

/**
 *
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
	/**
	 *
	 * @type {string}
	 * @memberof OrderItem
	 */
	external_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderItem
	 */
	image_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderItem
	 */
	item_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderItem
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof OrderItem
	 */
	price?: number;
}

/**
 *
 * @export
 * @interface OrderList
 */
export interface OrderList {
	/**
	 *
	 * @type {number}
	 * @memberof OrderList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Order>}
	 * @memberof OrderList
	 */
	items?: Array<Order>;
	/**
	 *
	 * @type {number}
	 * @memberof OrderList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface OrderUser
 */
export interface OrderUser {
	/**
	 *
	 * @type {string}
	 * @memberof OrderUser
	 */
	external_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderUser
	 */
	id?: string;
}

/**
 *
 * @export
 * @interface Organizer
 */
export interface Organizer {
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	cover?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	description?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	facebook?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Organizer
	 */
	followers_count?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	twitch?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	twitter?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	vk?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	website?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Organizer
	 */
	youtube?: string;
}

/**
 *
 * @export
 * @interface OrganizerSearch
 */
export interface OrganizerSearch {
	/**
	 *
	 * @type {boolean}
	 * @memberof OrganizerSearch
	 */
	active?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof OrganizerSearch
	 */
	avatar?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OrganizerSearch
	 */
	countries?: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OrganizerSearch
	 */
	games?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof OrganizerSearch
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrganizerSearch
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof OrganizerSearch
	 */
	partner?: boolean;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OrganizerSearch
	 */
	regions?: Array<string>;
}

/**
 *
 * @export
 * @interface OrganizersSearchList
 */
export interface OrganizersSearchList {
	/**
	 *
	 * @type {number}
	 * @memberof OrganizersSearchList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<OrganizerSearch>}
	 * @memberof OrganizersSearchList
	 */
	items?: Array<OrganizerSearch>;
	/**
	 *
	 * @type {number}
	 * @memberof OrganizersSearchList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface PaginationFields
 */
export interface PaginationFields {
	/**
	 *
	 * @type {number}
	 * @memberof PaginationFields
	 */
	end?: number;
	/**
	 *
	 * @type {number}
	 * @memberof PaginationFields
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface Placement
 */
export interface Placement {
	/**
	 *
	 * @type {string}
	 * @memberof Placement
	 */
	division_name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Placement
	 */
	division_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Placement
	 */
	ladder?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Placement
	 */
	matchmaking_id?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Placement
	 */
	season_number?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Placement
	 */
	tier_name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Placement
	 */
	tier_rank?: number;
}

/**
 *
 * @export
 * @interface Player
 */
export interface Player {
	/**
	 *
	 * @type {Date}
	 * @memberof Player
	 */
	activated_at?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	country?: string;
	/**
	 * Deprecated: no more in use
	 * @type {string}
	 * @memberof Player
	 */
	cover_featured_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	cover_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Player
	 */
	friends_ids?: Array<string>;
	/**
	 *
	 * @type {{ [key: string]: GameDetail; }}
	 * @memberof Player
	 */
	games?: { [key: string]: GameDetail };
	/**
	 * Deprecated: no more in use
	 * @type {any}
	 * @memberof Player
	 */
	infractions?: any;
	/**
	 * Deprecated: use memberships instead
	 * @type {string}
	 * @memberof Player
	 */
	membership_type?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Player
	 */
	memberships?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	new_steam_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	nickname?: string;
	/**
	 *
	 * @type {{ [key: string]: string; }}
	 * @memberof Player
	 */
	platforms?: { [key: string]: string };
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	player_id?: string;
	/**
	 *
	 * @type {UserSettings}
	 * @memberof Player
	 */
	settings?: UserSettings;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	steam_id_64?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Player
	 */
	steam_nickname?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Player
	 */
	verified?: boolean;
}

/**
 *
 * @export
 * @interface PlayerBan
 */
export interface PlayerBan {
	/**
	 *
	 * @type {Date}
	 * @memberof PlayerBan
	 */
	ends_at?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof PlayerBan
	 */
	game?: string;
	/**
	 *
	 * @type {string}
	 * @memberof PlayerBan
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof PlayerBan
	 */
	reason?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof PlayerBan
	 */
	starts_at?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof PlayerBan
	 */
	type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof PlayerBan
	 */
	user_id?: string;
}

/**
 *
 * @export
 * @interface PlayerBansList
 */
export interface PlayerBansList {
	/**
	 *
	 * @type {number}
	 * @memberof PlayerBansList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<PlayerBan>}
	 * @memberof PlayerBansList
	 */
	items?: Array<PlayerBan>;
	/**
	 *
	 * @type {number}
	 * @memberof PlayerBansList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface PlayerGlobalRanking
 */
export interface PlayerGlobalRanking {
	/**
	 *
	 * @type {number}
	 * @memberof PlayerGlobalRanking
	 */
	end?: number;
	/**
	 *
	 * @type {Array<GlobalRanking>}
	 * @memberof PlayerGlobalRanking
	 */
	items?: Array<GlobalRanking>;
	/**
	 *
	 * @type {number}
	 * @memberof PlayerGlobalRanking
	 */
	position?: number;
	/**
	 *
	 * @type {number}
	 * @memberof PlayerGlobalRanking
	 */
	start?: number;
}

/**
 * PlayerInLeague holds information about a player in a league.
 * @export
 * @interface PlayerInLeague
 */
export interface PlayerInLeague {
	/**
	 * The division name that the player is in.
	 * @type {string}
	 * @memberof PlayerInLeague
	 */
	division_name?: string;
	/**
	 * The division tier that the player is in.
	 * @type {string}
	 * @memberof PlayerInLeague
	 */
	division_tier?: string;
	/**
	 * The division type that the player is in.
	 * @type {string}
	 * @memberof PlayerInLeague
	 */
	division_type?: string;
	/**
	 * The leaderboard id that the player is in.
	 * @type {string}
	 * @memberof PlayerInLeague
	 */
	leaderboard_id?: string;
	/**
	 * The points of the player in the leaderboard.
	 * @type {number}
	 * @memberof PlayerInLeague
	 */
	points?: number;
	/**
	 * The position of the player in the leaderboard.
	 * @type {number}
	 * @memberof PlayerInLeague
	 */
	position?: number;
}

/**
 *
 * @export
 * @interface PlayerStats
 */
export interface PlayerStats {
	/**
	 *
	 * @type {string}
	 * @memberof PlayerStats
	 */
	game_id?: string;
	/**
	 *
	 * @type {{ [key: string]: any; }}
	 * @memberof PlayerStats
	 */
	lifetime?: { [key: string]: any };
	/**
	 *
	 * @type {string}
	 * @memberof PlayerStats
	 */
	player_id?: string;
	/**
	 *
	 * @type {Array<{ [key: string]: any; }>}
	 * @memberof PlayerStats
	 */
	segments?: Array<{ [key: string]: any }>;
}

/**
 *
 * @export
 * @interface PlayerStatsForMatch
 */
export interface PlayerStatsForMatch {
	/**
	 *
	 * @type {{ [key: string]: any; }}
	 * @memberof PlayerStatsForMatch
	 */
	stats?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface PlayerStatsForMatchesList
 */
export interface PlayerStatsForMatchesList {
	/**
	 *
	 * @type {number}
	 * @memberof PlayerStatsForMatchesList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<PlayerStatsForMatch>}
	 * @memberof PlayerStatsForMatchesList
	 */
	items?: Array<PlayerStatsForMatch>;
	/**
	 *
	 * @type {number}
	 * @memberof PlayerStatsForMatchesList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface PlayerStatsSimple
 */
export interface PlayerStatsSimple {
	/**
	 *
	 * @type {any}
	 * @memberof PlayerStatsSimple
	 */
	nickname?: any;
	/**
	 *
	 * @type {any}
	 * @memberof PlayerStatsSimple
	 */
	player_id?: any;
	/**
	 *
	 * @type {{ [key: string]: any; }}
	 * @memberof PlayerStatsSimple
	 */
	player_stats?: { [key: string]: any };
}

/**
 * Plugin A plugin for the Engine API
 * @export
 * @interface Plugin
 */
export interface Plugin {
	/**
	 *
	 * @type {PluginConfig}
	 * @memberof Plugin
	 */
	Config: PluginConfig;
	/**
	 * True if the plugin is running. False if the plugin is not running, only installed.
	 * @type {boolean}
	 * @memberof Plugin
	 */
	Enabled: boolean;
	/**
	 * Id
	 * @type {string}
	 * @memberof Plugin
	 */
	Id?: string;
	/**
	 * name
	 * @type {string}
	 * @memberof Plugin
	 */
	Name: string;
	/**
	 * plugin remote reference used to push/pull the plugin
	 * @type {string}
	 * @memberof Plugin
	 */
	PluginReference?: string;
	/**
	 *
	 * @type {PluginSettings}
	 * @memberof Plugin
	 */
	Settings: PluginSettings;
}

/**
 *
 * @export
 * @interface PluginConfig
 */
export interface PluginConfig {
	/**
	 *
	 * @type {PluginConfigArgs}
	 * @memberof PluginConfig
	 */
	Args: PluginConfigArgs;
	/**
	 * description
	 * @type {string}
	 * @memberof PluginConfig
	 */
	Description: string;
	/**
	 * Docker Version used to create the plugin
	 * @type {string}
	 * @memberof PluginConfig
	 */
	DockerVersion?: string;
	/**
	 * documentation
	 * @type {string}
	 * @memberof PluginConfig
	 */
	Documentation: string;
	/**
	 * entrypoint
	 * @type {Array<string>}
	 * @memberof PluginConfig
	 */
	Entrypoint: Array<string>;
	/**
	 * env
	 * @type {Array<PluginEnv>}
	 * @memberof PluginConfig
	 */
	Env: Array<PluginEnv>;
	/**
	 *
	 * @type {PluginConfigInterface}
	 * @memberof PluginConfig
	 */
	_Interface: PluginConfigInterface;
	/**
	 * ipc host
	 * @type {boolean}
	 * @memberof PluginConfig
	 */
	IpcHost: boolean;
	/**
	 *
	 * @type {PluginConfigLinux}
	 * @memberof PluginConfig
	 */
	Linux: PluginConfigLinux;
	/**
	 * mounts
	 * @type {Array<PluginMount>}
	 * @memberof PluginConfig
	 */
	Mounts: Array<PluginMount>;
	/**
	 *
	 * @type {PluginConfigNetwork}
	 * @memberof PluginConfig
	 */
	Network: PluginConfigNetwork;
	/**
	 * pid host
	 * @type {boolean}
	 * @memberof PluginConfig
	 */
	PidHost: boolean;
	/**
	 * propagated mount
	 * @type {string}
	 * @memberof PluginConfig
	 */
	PropagatedMount: string;
	/**
	 *
	 * @type {PluginConfigUser}
	 * @memberof PluginConfig
	 */
	User?: PluginConfigUser;
	/**
	 * work dir
	 * @type {string}
	 * @memberof PluginConfig
	 */
	WorkDir: string;
	/**
	 *
	 * @type {PluginConfigRootfs}
	 * @memberof PluginConfig
	 */
	rootfs?: PluginConfigRootfs;
}

/**
 * PluginConfigArgs plugin config args
 * @export
 * @interface PluginConfigArgs
 */
export interface PluginConfigArgs {
	/**
	 * description
	 * @type {string}
	 * @memberof PluginConfigArgs
	 */
	Description: string;
	/**
	 * name
	 * @type {string}
	 * @memberof PluginConfigArgs
	 */
	Name: string;
	/**
	 * settable
	 * @type {Array<string>}
	 * @memberof PluginConfigArgs
	 */
	Settable: Array<string>;
	/**
	 * value
	 * @type {Array<string>}
	 * @memberof PluginConfigArgs
	 */
	Value: Array<string>;
}

/**
 * PluginConfigInterface The interface between Docker and the plugin
 * @export
 * @interface PluginConfigInterface
 */
export interface PluginConfigInterface {
	/**
	 * Protocol to use for clients connecting to the plugin.
	 * @type {string}
	 * @memberof PluginConfigInterface
	 */
	ProtocolScheme?: string;
	/**
	 * socket
	 * @type {string}
	 * @memberof PluginConfigInterface
	 */
	Socket: string;
	/**
	 * types
	 * @type {Array<PluginInterfaceType>}
	 * @memberof PluginConfigInterface
	 */
	Types: Array<PluginInterfaceType>;
}

/**
 * PluginConfigLinux plugin config linux
 * @export
 * @interface PluginConfigLinux
 */
export interface PluginConfigLinux {
	/**
	 * allow all devices
	 * @type {boolean}
	 * @memberof PluginConfigLinux
	 */
	AllowAllDevices: boolean;
	/**
	 * capabilities
	 * @type {Array<string>}
	 * @memberof PluginConfigLinux
	 */
	Capabilities: Array<string>;
	/**
	 * devices
	 * @type {Array<PluginDevice>}
	 * @memberof PluginConfigLinux
	 */
	Devices: Array<PluginDevice>;
}

/**
 * PluginConfigNetwork plugin config network
 * @export
 * @interface PluginConfigNetwork
 */
export interface PluginConfigNetwork {
	/**
	 * type
	 * @type {string}
	 * @memberof PluginConfigNetwork
	 */
	Type: string;
}

/**
 * PluginConfigRootfs plugin config rootfs
 * @export
 * @interface PluginConfigRootfs
 */
export interface PluginConfigRootfs {
	/**
	 * diff ids
	 * @type {Array<string>}
	 * @memberof PluginConfigRootfs
	 */
	diff_ids?: Array<string>;
	/**
	 * type
	 * @type {string}
	 * @memberof PluginConfigRootfs
	 */
	type?: string;
}

/**
 * PluginConfigUser plugin config user
 * @export
 * @interface PluginConfigUser
 */
export interface PluginConfigUser {
	/**
	 * g ID
	 * @type {number}
	 * @memberof PluginConfigUser
	 */
	GID?: number;
	/**
	 * UID
	 * @type {number}
	 * @memberof PluginConfigUser
	 */
	UID?: number;
}

/**
 * PluginDevice plugin device
 * @export
 * @interface PluginDevice
 */
export interface PluginDevice {
	/**
	 * description
	 * @type {string}
	 * @memberof PluginDevice
	 */
	Description: string;
	/**
	 * name
	 * @type {string}
	 * @memberof PluginDevice
	 */
	Name: string;
	/**
	 * path
	 * @type {string}
	 * @memberof PluginDevice
	 */
	Path: string;
	/**
	 * settable
	 * @type {Array<string>}
	 * @memberof PluginDevice
	 */
	Settable: Array<string>;
}

/**
 * PluginEnv plugin env
 * @export
 * @interface PluginEnv
 */
export interface PluginEnv {
	/**
	 * description
	 * @type {string}
	 * @memberof PluginEnv
	 */
	Description: string;
	/**
	 * name
	 * @type {string}
	 * @memberof PluginEnv
	 */
	Name: string;
	/**
	 * settable
	 * @type {Array<string>}
	 * @memberof PluginEnv
	 */
	Settable: Array<string>;
	/**
	 * value
	 * @type {string}
	 * @memberof PluginEnv
	 */
	Value: string;
}

/**
 * PluginInterfaceType plugin interface type
 * @export
 * @interface PluginInterfaceType
 */
export interface PluginInterfaceType {
	/**
	 * capability
	 * @type {string}
	 * @memberof PluginInterfaceType
	 */
	Capability: string;
	/**
	 * prefix
	 * @type {string}
	 * @memberof PluginInterfaceType
	 */
	Prefix: string;
	/**
	 * version
	 * @type {string}
	 * @memberof PluginInterfaceType
	 */
	Version: string;
}

/**
 * PluginMount plugin mount
 * @export
 * @interface PluginMount
 */
export interface PluginMount {
	/**
	 * description
	 * @type {string}
	 * @memberof PluginMount
	 */
	Description: string;
	/**
	 * destination
	 * @type {string}
	 * @memberof PluginMount
	 */
	Destination: string;
	/**
	 * name
	 * @type {string}
	 * @memberof PluginMount
	 */
	Name: string;
	/**
	 * options
	 * @type {Array<string>}
	 * @memberof PluginMount
	 */
	Options: Array<string>;
	/**
	 * settable
	 * @type {Array<string>}
	 * @memberof PluginMount
	 */
	Settable: Array<string>;
	/**
	 * source
	 * @type {string}
	 * @memberof PluginMount
	 */
	Source: string;
	/**
	 * type
	 * @type {string}
	 * @memberof PluginMount
	 */
	Type: string;
}

/**
 *
 * @export
 * @interface PluginSettings
 */
export interface PluginSettings {
	/**
	 * args
	 * @type {Array<string>}
	 * @memberof PluginSettings
	 */
	Args: Array<string>;
	/**
	 * devices
	 * @type {Array<PluginDevice>}
	 * @memberof PluginSettings
	 */
	Devices: Array<PluginDevice>;
	/**
	 * env
	 * @type {Array<string>}
	 * @memberof PluginSettings
	 */
	Env: Array<string>;
	/**
	 * mounts
	 * @type {Array<PluginMount>}
	 * @memberof PluginSettings
	 */
	Mounts: Array<PluginMount>;
}

/**
 * Port An open port on a container
 * @export
 * @interface Port
 */
export interface Port {
	/**
	 * Host IP address that the container's port is mapped to
	 * @type {string}
	 * @memberof Port
	 */
	IP?: string;
	/**
	 * Port on the container
	 * @type {number}
	 * @memberof Port
	 */
	PrivatePort: number;
	/**
	 * Port exposed on the host
	 * @type {number}
	 * @memberof Port
	 */
	PublicPort?: number;
	/**
	 * type
	 * @type {string}
	 * @memberof Port
	 */
	Type: string;
}

/**
 *
 * @export
 * @interface Prize
 */
export interface Prize {
	/**
	 *
	 * @type {number}
	 * @memberof Prize
	 */
	faceit_points?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Prize
	 */
	rank?: number;
}

/**
 * Promotion holds information about what is required in order for a player to be promoted to the next tier.
 * @export
 * @interface Promotion
 */
export interface Promotion {
	/**
	 * Points needed for a player to get promoted.
	 * @type {number}
	 * @memberof Promotion
	 */
	points?: number;
}

/**
 * PublishState represents the state of a Volume as it pertains to its use on a particular Node.
 * @export
 * @interface PublishState
 */
export type PublishState = {};

/**
 * PublishStatus represents the status of the volume as published to an individual node
 * @export
 * @interface PublishStatus
 */
export interface PublishStatus {
	/**
	 * NodeID is the ID of the swarm node this Volume is published to.
	 * @type {string}
	 * @memberof PublishStatus
	 */
	NodeID?: string;
	/**
	 * PublishContext is the PublishContext returned by the CSI plugin when a volume is published.
	 * @type {{ [key: string]: string; }}
	 * @memberof PublishStatus
	 */
	PublishContext?: { [key: string]: string };
	/**
	 *
	 * @type {PublishState}
	 * @memberof PublishStatus
	 */
	State?: PublishState;
}

/**
 *
 * @export
 * @interface Queue
 */
export interface Queue {
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	adminTool?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	anticheatRequired?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	calculateElo?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	captainSelection?: string;
	/**
	 *
	 * @type {CheckIn}
	 * @memberof Queue
	 */
	checkIn?: CheckIn;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	entityId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	entityType?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	fbiManagement?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	game?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	groupSimilar?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	id?: string;
	/**
	 *
	 * @type {JoinType}
	 * @memberof Queue
	 */
	joinType?: JoinType;
	/**
	 *
	 * @type {Date}
	 * @memberof Queue
	 */
	lastModified?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof Queue
	 */
	maxSkill?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Queue
	 */
	minSkill?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Queue
	 */
	noOfPlayers?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	open?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	organizerId?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	paused?: boolean;
	/**
	 *
	 * @type {QueueAlgorithm}
	 * @memberof Queue
	 */
	queueAlgorithm?: QueueAlgorithm;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	queueName?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	region?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Queue
	 */
	state?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Queue
	 */
	verifiedMatching?: boolean;
}

/**
 *
 * @export
 * @interface QueueAlgorithm
 */
export interface QueueAlgorithm {
	/**
	 *
	 * @type {string}
	 * @memberof QueueAlgorithm
	 */
	algorithmId?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof QueueAlgorithm
	 */
	algorithmInput?: Array<string>;
	/**
	 *
	 * @type {AlgorithmParameters}
	 * @memberof QueueAlgorithm
	 */
	algorithmParameters?: AlgorithmParameters;
	/**
	 *
	 * @type {GeoDescription}
	 * @memberof QueueAlgorithm
	 */
	geoDescription?: GeoDescription;
	/**
	 *
	 * @type {GeoLabel}
	 * @memberof QueueAlgorithm
	 */
	geoLabel?: GeoLabel;
	/**
	 *
	 * @type {string}
	 * @memberof QueueAlgorithm
	 */
	id?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof QueueAlgorithm
	 */
	roleBasedCaptainPick?: boolean;
}

/**
 *
 * @export
 * @interface QueueBan
 */
export interface QueueBan {
	/**
	 *
	 * @type {Date}
	 * @memberof QueueBan
	 */
	banEnd?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	banId?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof QueueBan
	 */
	banStart?: Date;
	/**
	 *
	 * @type {Date}
	 * @memberof QueueBan
	 */
	createdAt?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	entityId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	entityType?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof QueueBan
	 */
	expired?: boolean;
	/**
	 *
	 * @type {Date}
	 * @memberof QueueBan
	 */
	lastModified?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	organizerId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	queueId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	reason?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueBan
	 */
	userId?: string;
	/**
	 *
	 * @type {number}
	 * @memberof QueueBan
	 */
	version?: number;
}

/**
 *
 * @export
 * @interface QueueBansList
 */
export interface QueueBansList {
	/**
	 *
	 * @type {number}
	 * @memberof QueueBansList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<QueueBan>}
	 * @memberof QueueBansList
	 */
	items?: Array<QueueBan>;
	/**
	 *
	 * @type {number}
	 * @memberof QueueBansList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface QueueSimple
 */
export interface QueueSimple {
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	entityId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	entityType?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	game?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	id?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof QueueSimple
	 */
	lastModified?: Date;
	/**
	 *
	 * @type {boolean}
	 * @memberof QueueSimple
	 */
	open?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	organizerId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	queueName?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	region?: string;
	/**
	 *
	 * @type {string}
	 * @memberof QueueSimple
	 */
	state?: string;
}

/**
 *
 * @export
 * @interface QueuesList
 */
export interface QueuesList {
	/**
	 *
	 * @type {number}
	 * @memberof QueuesList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<QueueSimple>}
	 * @memberof QueuesList
	 */
	items?: Array<QueueSimple>;
	/**
	 *
	 * @type {number}
	 * @memberof QueuesList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface Ranking
 */
export interface Ranking {
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	current_streak?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	draw?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	lost?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	played?: number;
	/**
	 *
	 * @type {UserSimple}
	 * @memberof Ranking
	 */
	player?: UserSimple;
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	points?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	position?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	win_rate?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Ranking
	 */
	won?: number;
}

/**
 * Relegation holds information about what is required in order for a player to be relegated to the previous tier.
 * @export
 * @interface Relegation
 */
export interface Relegation {
	/**
	 * Consecutive losses needed for a player to get relegated to the previous tier.
	 * @type {number}
	 * @memberof Relegation
	 */
	consecutive_losses?: number;
}

/**
 *
 * @export
 * @interface Role
 */
export interface Role {
	/**
	 *
	 * @type {string}
	 * @memberof Role
	 */
	color?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Role
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Role
	 */
	ranking?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Role
	 */
	role_id?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Role
	 */
	visible_on_chat?: boolean;
}

/**
 *
 * @export
 * @interface RolesList
 */
export interface RolesList {
	/**
	 *
	 * @type {number}
	 * @memberof RolesList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<Role>}
	 * @memberof RolesList
	 */
	items?: Array<Role>;
	/**
	 *
	 * @type {number}
	 * @memberof RolesList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface Roster
 */
export interface Roster {
	/**
	 *
	 * @type {boolean}
	 * @memberof Roster
	 */
	anticheat_required?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Roster
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Roster
	 */
	game_player_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Roster
	 */
	game_player_name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Roster
	 */
	game_skill_level?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Roster
	 */
	membership?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Roster
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Roster
	 */
	player_id?: string;
}

/**
 *
 * @export
 * @interface RoundStats
 */
export interface RoundStats {
	/**
	 *
	 * @type {any}
	 * @memberof RoundStats
	 */
	best_of?: any;
	/**
	 *
	 * @type {any}
	 * @memberof RoundStats
	 */
	competition_id?: any;
	/**
	 *
	 * @type {any}
	 * @memberof RoundStats
	 */
	game_id?: any;
	/**
	 *
	 * @type {any}
	 * @memberof RoundStats
	 */
	game_mode?: any;
	/**
	 *
	 * @type {any}
	 * @memberof RoundStats
	 */
	match_id?: any;
	/**
	 *
	 * @type {any}
	 * @memberof RoundStats
	 */
	match_round?: any;
	/**
	 *
	 * @type {any}
	 * @memberof RoundStats
	 */
	played?: any;
	/**
	 *
	 * @type {{ [key: string]: any; }}
	 * @memberof RoundStats
	 */
	round_stats?: { [key: string]: any };
	/**
	 *
	 * @type {Array<TeamStatsSimple>}
	 * @memberof RoundStats
	 */
	teams?: Array<TeamStatsSimple>;
}

/**
 *
 * @export
 * @interface Rules
 */
export interface Rules {
	/**
	 *
	 * @type {string}
	 * @memberof Rules
	 */
	body?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Rules
	 */
	game?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Rules
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Rules
	 */
	organizer?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Rules
	 */
	rule_id?: string;
}

/**
 * Scope defines the Scope of a Cluster Volume. This is how many nodes a Volume can be accessed simultaneously on.
 * @export
 * @interface Scope
 */
export type Scope = {};

/**
 * Season holds information about a league season. When no older season is requested, this field holds information about the season of the league.
 * @export
 * @interface Season
 */
export interface Season {
	/**
	 * The end date of the season.
	 * @type {Date}
	 * @memberof Season
	 */
	end_date?: Date;
	/**
	 * The season number.
	 * @type {number}
	 * @memberof Season
	 */
	number?: number;
	/**
	 * The placement match mount.
	 * @type {number}
	 * @memberof Season
	 */
	placement_match_count?: number;
	/**
	 * The start date of the season.
	 * @type {Date}
	 * @memberof Season
	 */
	start_date?: Date;
}

/**
 *
 * @export
 * @interface SeasonDetailed
 */
export interface SeasonDetailed {
	/**
	 * The divisions of the given season.
	 * @type {Array<Division>}
	 * @memberof SeasonDetailed
	 */
	divisions?: Array<Division>;
	/**
	 *
	 * @type {Season}
	 * @memberof SeasonDetailed
	 */
	season?: Season;
}

/**
 * Secret represents a Swarm Secret value that must be passed to the CSI storage plugin when operating on this Volume. It represents one key-value pair of possibly many.
 * @export
 * @interface Secret
 */
export interface Secret {
	/**
	 * Key is the name of the key of the key-value pair passed to the plugin.
	 * @type {string}
	 * @memberof Secret
	 */
	Key?: string;
	/**
	 * Secret is the swarm Secret object from which to read data. This can be a Secret name or ID. The Secret data is retrieved by Swarm and used as the value of the key-value pair passed to the plugin.
	 * @type {string}
	 * @memberof Secret
	 */
	Secret?: string;
}

/**
 * ServiceCreateResponse contains the information returned to a client on the creation of a new service.
 * @export
 * @interface ServiceCreateResponse
 */
export interface ServiceCreateResponse {
	/**
	 * The ID of the created service.
	 * @type {string}
	 * @memberof ServiceCreateResponse
	 */
	ID?: string;
	/**
	 * Optional warning message.  FIXME(thaJeztah): this should have \"omitempty\" in the generated type.
	 * @type {Array<string>}
	 * @memberof ServiceCreateResponse
	 */
	Warnings?: Array<string>;
}

/**
 * ServiceUpdateResponse service update response
 * @export
 * @interface ServiceUpdateResponse
 */
export interface ServiceUpdateResponse {
	/**
	 * Optional warning messages
	 * @type {Array<string>}
	 * @memberof ServiceUpdateResponse
	 */
	Warnings?: Array<string>;
}

/**
 * SharingMode defines the Sharing of a Cluster Volume. This is how Tasks using a Volume at the same time can use it.
 * @export
 * @interface SharingMode
 */
export type SharingMode = {};

/**
 *
 * @export
 * @interface SpacePlayer
 */
export interface SpacePlayer {
	/**
	 *
	 * @type {Date}
	 * @memberof SpacePlayer
	 */
	activated_at?: Date;
	/**
	 *
	 * @type {Address}
	 * @memberof SpacePlayer
	 */
	address?: Address;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	avatar?: string;
	/**
	 *
	 * @type {BirthDate}
	 * @memberof SpacePlayer
	 */
	birth_date?: BirthDate;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	country?: string;
	/**
	 * Deprecated: no more in use
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	cover_featured_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	cover_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	email?: string;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	first_name?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof SpacePlayer
	 */
	friends_ids?: Array<string>;
	/**
	 *
	 * @type {{ [key: string]: GameDetail; }}
	 * @memberof SpacePlayer
	 */
	games?: { [key: string]: GameDetail };
	/**
	 * Deprecated: no more in use
	 * @type {any}
	 * @memberof SpacePlayer
	 */
	infractions?: any;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	last_name?: string;
	/**
	 * Deprecated: use memberships instead
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	membership_type?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof SpacePlayer
	 */
	memberships?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	new_steam_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	nickname?: string;
	/**
	 *
	 * @type {{ [key: string]: string; }}
	 * @memberof SpacePlayer
	 */
	platforms?: { [key: string]: string };
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	player_id?: string;
	/**
	 *
	 * @type {UserSettings}
	 * @memberof SpacePlayer
	 */
	settings?: UserSettings;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	steam_id_64?: string;
	/**
	 *
	 * @type {string}
	 * @memberof SpacePlayer
	 */
	steam_nickname?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof SpacePlayer
	 */
	verified?: boolean;
}

/**
 *
 * @export
 * @interface Stats
 */
export interface Stats {
	/**
	 *
	 * @type {number}
	 * @memberof Stats
	 */
	rating?: number;
	/**
	 *
	 * @type {StatsSkillLevel}
	 * @memberof Stats
	 */
	skillLevel?: StatsSkillLevel;
	/**
	 *
	 * @type {number}
	 * @memberof Stats
	 */
	winProbability?: number;
}

/**
 *
 * @export
 * @interface StatsCompetitionPlayer
 */
export interface StatsCompetitionPlayer {
	/**
	 *
	 * @type {string}
	 * @memberof StatsCompetitionPlayer
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof StatsCompetitionPlayer
	 */
	player_id?: string;
	/**
	 *
	 * @type {{ [key: string]: any; }}
	 * @memberof StatsCompetitionPlayer
	 */
	stats?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface StatsSkillLevel
 */
export interface StatsSkillLevel {
	/**
	 *
	 * @type {number}
	 * @memberof StatsSkillLevel
	 */
	average?: number;
	/**
	 *
	 * @type {StatsSkillLevelRange}
	 * @memberof StatsSkillLevel
	 */
	range?: StatsSkillLevelRange;
}

/**
 *
 * @export
 * @interface StatsSkillLevelRange
 */
export interface StatsSkillLevelRange {
	/**
	 *
	 * @type {number}
	 * @memberof StatsSkillLevelRange
	 */
	max?: number;
	/**
	 *
	 * @type {number}
	 * @memberof StatsSkillLevelRange
	 */
	min?: number;
}

/**
 *
 * @export
 * @interface SubstitutionConfiguration
 */
export interface SubstitutionConfiguration {
	/**
	 *
	 * @type {number}
	 * @memberof SubstitutionConfiguration
	 */
	max_substitutes?: number;
	/**
	 *
	 * @type {number}
	 * @memberof SubstitutionConfiguration
	 */
	max_substitutions?: number;
}

/**
 * Summary summary
 * @export
 * @interface Summary
 */
export interface Summary {
	/**
	 * Number of containers using this image. Includes both stopped and running containers.  This size is not calculated by default, and depends on which API endpoint is used. `-1` indicates that the value has not been set / calculated.
	 * @type {number}
	 * @memberof Summary
	 */
	Containers: number;
	/**
	 * Date and time at which the image was created as a Unix timestamp (number of seconds sinds EPOCH).
	 * @type {number}
	 * @memberof Summary
	 */
	Created: number;
	/**
	 * ID is the content-addressable ID of an image.  This identifier is a content-addressable digest calculated from the image's configuration (which includes the digests of layers used by the image).  Note that this digest differs from the `RepoDigests` below, which holds digests of image manifests that reference the image.
	 * @type {string}
	 * @memberof Summary
	 */
	Id: string;
	/**
	 * User-defined key/value metadata.
	 * @type {{ [key: string]: string; }}
	 * @memberof Summary
	 */
	Labels: { [key: string]: string };
	/**
	 * ID of the parent image.  Depending on how the image was created, this field may be empty and is only set for images that were built/created locally. This field is empty if the image was pulled from an image registry.
	 * @type {string}
	 * @memberof Summary
	 */
	ParentId: string;
	/**
	 * List of content-addressable digests of locally available image manifests that the image is referenced from. Multiple manifests can refer to the same image.  These digests are usually only available if the image was either pulled from a registry, or if the image was pushed to a registry, which is when the manifest is generated and its digest calculated.
	 * @type {Array<string>}
	 * @memberof Summary
	 */
	RepoDigests: Array<string>;
	/**
	 * List of image names/tags in the local image cache that reference this image.  Multiple image tags can refer to the same image, and this list may be empty if no tags reference the image, in which case the image is \"untagged\", in which case it can still be referenced by its ID.
	 * @type {Array<string>}
	 * @memberof Summary
	 */
	RepoTags: Array<string>;
	/**
	 * Total size of image layers that are shared between this image and other images.  This size is not calculated by default. `-1` indicates that the value has not been set / calculated.
	 * @type {number}
	 * @memberof Summary
	 */
	SharedSize: number;
	/**
	 * Total size of the image including all layers it is composed of.
	 * @type {number}
	 * @memberof Summary
	 */
	Size: number;
	/**
	 * Total size of the image including all layers it is composed of.  Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
	 * @type {number}
	 * @memberof Summary
	 */
	VirtualSize?: number;
}

/**
 * The Team holds information about a team.
 * @export
 * @interface Team
 */
export interface Team {
	/**
	 * The Avatar of a team
	 * @type {string}
	 * @memberof Team
	 */
	avatar?: string;
	/**
	 * The ChatID of a team
	 * @type {string}
	 * @memberof Team
	 */
	chat_room_id?: string;
	/**
	 * The CoverImage of a team
	 * @type {string}
	 * @memberof Team
	 */
	cover_image?: string;
	/**
	 * The Description of a team
	 * @type {string}
	 * @memberof Team
	 */
	description?: string;
	/**
	 * The Facebook of a team
	 * @type {string}
	 * @memberof Team
	 */
	facebook?: string;
	/**
	 * The FaceitUrl of a team
	 * @type {string}
	 * @memberof Team
	 */
	faceit_url?: string;
	/**
	 * The Game of a team
	 * @type {string}
	 * @memberof Team
	 */
	game?: string;
	/**
	 * The Leader of a team
	 * @type {string}
	 * @memberof Team
	 */
	leader?: string;
	/**
	 * The Members of a team  Can be empty if not supported
	 * @type {Array<UserSimple>}
	 * @memberof Team
	 */
	members?: Array<UserSimple>;
	/**
	 * The Name of a team
	 * @type {string}
	 * @memberof Team
	 */
	name?: string;
	/**
	 * The Nickname of a team
	 * @type {string}
	 * @memberof Team
	 */
	nickname?: string;
	/**
	 * The ID of a team
	 * @type {string}
	 * @memberof Team
	 */
	team_id?: string;
	/**
	 * The TeamType of a team
	 * @type {string}
	 * @memberof Team
	 */
	team_type?: string;
	/**
	 * The Twitter of a team
	 * @type {string}
	 * @memberof Team
	 */
	twitter?: string;
	/**
	 * The Website of a team
	 * @type {string}
	 * @memberof Team
	 */
	website?: string;
	/**
	 * The Youtube of a team
	 * @type {string}
	 * @memberof Team
	 */
	youtube?: string;
}

/**
 * The TeamList holds teams information.
 * @export
 * @interface TeamList
 */
export interface TeamList {
	/**
	 *
	 * @type {number}
	 * @memberof TeamList
	 */
	end?: number;
	/**
	 * The teams list.
	 * @type {Array<Team>}
	 * @memberof TeamList
	 */
	items: Array<Team>;
	/**
	 *
	 * @type {number}
	 * @memberof TeamList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface TeamSearch
 */
export interface TeamSearch {
	/**
	 *
	 * @type {string}
	 * @memberof TeamSearch
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TeamSearch
	 */
	chat_room_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TeamSearch
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TeamSearch
	 */
	game?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TeamSearch
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TeamSearch
	 */
	team_id?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof TeamSearch
	 */
	verified?: boolean;
}

/**
 *
 * @export
 * @interface TeamStats
 */
export interface TeamStats {
	/**
	 *
	 * @type {string}
	 * @memberof TeamStats
	 */
	game_id?: string;
	/**
	 *
	 * @type {{ [key: string]: any; }}
	 * @memberof TeamStats
	 */
	lifetime?: { [key: string]: any };
	/**
	 *
	 * @type {Array<{ [key: string]: any; }>}
	 * @memberof TeamStats
	 */
	segments?: Array<{ [key: string]: any }>;
	/**
	 *
	 * @type {string}
	 * @memberof TeamStats
	 */
	team_id?: string;
}

/**
 *
 * @export
 * @interface TeamStatsSimple
 */
export interface TeamStatsSimple {
	/**
	 *
	 * @type {Array<PlayerStatsSimple>}
	 * @memberof TeamStatsSimple
	 */
	players?: Array<PlayerStatsSimple>;
	/**
	 *
	 * @type {any}
	 * @memberof TeamStatsSimple
	 */
	premade?: any;
	/**
	 *
	 * @type {any}
	 * @memberof TeamStatsSimple
	 */
	team_id?: any;
	/**
	 *
	 * @type {{ [key: string]: any; }}
	 * @memberof TeamStatsSimple
	 */
	team_stats?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface TeamsSearchList
 */
export interface TeamsSearchList {
	/**
	 *
	 * @type {number}
	 * @memberof TeamsSearchList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<TeamSearch>}
	 * @memberof TeamsSearchList
	 */
	items?: Array<TeamSearch>;
	/**
	 *
	 * @type {number}
	 * @memberof TeamsSearchList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface Tier
 */
export interface Tier {
	/**
	 * The name of the tier
	 * @type {string}
	 * @memberof Tier
	 */
	name?: string;
	/**
	 * The target points for the tier
	 * @type {number}
	 * @memberof Tier
	 */
	points_target?: number;
	/**
	 * The rank of the tier
	 * @type {number}
	 * @memberof Tier
	 */
	rank?: number;
}

/**
 * This description is taken verbatim from the CSI Spec:  A topological domain is a sub-division of a cluster, like \"region\", \"zone\", \"rack\", etc. A topological segment is a specific instance of a topological domain, like \"zone3\", \"rack3\", etc. For example {\"com.company/zone\": \"Z1\", \"com.company/rack\": \"R3\"} Valid keys have two segments: an OPTIONAL prefix and name, separated by a slash (/), for example: \"com.company.example/zone\". The key name segment is REQUIRED. The prefix is OPTIONAL. The key name MUST be 63 characters or less, begin and end with an alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-), underscores (_), dots (.), or alphanumerics in between, for example \"zone\". The key prefix MUST be 63 characters or less, begin and end with a lower-case alphanumeric character ([a-z0-9]), contain only dashes (-), dots (.), or lower-case alphanumerics in between, and follow domain name notation format (https://tools.ietf.org/html/rfc1035#section-2.3.1). The key prefix SHOULD include the plugin's host company name and/or the plugin name, to minimize the possibility of collisions with keys from other plugins. If a key prefix is specified, it MUST be identical across all topology keys returned by the SP (across all RPCs). Keys MUST be case-insensitive. Meaning the keys \"Zone\" and \"zone\" MUST not both exist. Each value (topological segment) MUST contain 1 or more strings. Each string MUST be 63 characters or less and begin and end with an alphanumeric character with '-', '_', '.', or alphanumerics in between.
 * @export
 * @interface Topology
 */
export interface Topology {
	/**
	 *
	 * @type {{ [key: string]: string; }}
	 * @memberof Topology
	 */
	Segments?: { [key: string]: string };
}

/**
 * TopologyRequirement expresses the user's requirements for a volume's accessible topology.
 * @export
 * @interface TopologyRequirement
 */
export interface TopologyRequirement {
	/**
	 * Preferred is a list of Topologies that the volume should attempt to be provisioned in.  Taken from the CSI spec:  Specifies the list of topologies the CO would prefer the volume to be provisioned in.  This field is OPTIONAL. If TopologyRequirement is specified either requisite or preferred or both MUST be specified.  An SP MUST attempt to make the provisioned volume available using the preferred topologies in order from first to last.  If requisite is specified, all topologies in preferred list MUST also be present in the list of requisite topologies.  If the SP is unable to make the provisioned volume available from any of the preferred topologies, the SP MAY choose a topology from the list of requisite topologies. If the list of requisite topologies is not specified, then the SP MAY choose from the list of all possible topologies. If the list of requisite topologies is specified and the SP is unable to make the provisioned volume available from any of the requisite topologies it MUST fail the CreateVolume call.  Example 1: Given a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} preferred = {\"region\": \"R1\", \"zone\": \"Z3\"} then the SP SHOULD first attempt to make the provisioned volume available from \"zone\" \"Z3\" in the \"region\" \"R1\" and fall back to \"zone\" \"Z2\" in the \"region\" \"R1\" if that is not possible.  Example 2: Given a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"}, {\"region\": \"R1\", \"zone\": \"Z4\"}, {\"region\": \"R1\", \"zone\": \"Z5\"} preferred = {\"region\": \"R1\", \"zone\": \"Z4\"}, {\"region\": \"R1\", \"zone\": \"Z2\"} then the SP SHOULD first attempt to make the provisioned volume accessible from \"zone\" \"Z4\" in the \"region\" \"R1\" and fall back to \"zone\" \"Z2\" in the \"region\" \"R1\" if that is not possible. If that is not possible, the SP may choose between either the \"zone\" \"Z3\" or \"Z5\" in the \"region\" \"R1\".  Example 3: Given a volume should be accessible from TWO zones (because an opaque parameter in CreateVolumeRequest, for example, specifies the volume is accessible from two zones, aka synchronously replicated), and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"}, {\"region\": \"R1\", \"zone\": \"Z4\"}, {\"region\": \"R1\", \"zone\": \"Z5\"} preferred = {\"region\": \"R1\", \"zone\": \"Z5\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} then the SP SHOULD first attempt to make the provisioned volume accessible from the combination of the two \"zones\" \"Z5\" and \"Z3\" in the \"region\" \"R1\". If that's not possible, it should fall back to a combination of \"Z5\" and other possibilities from the list of requisite. If that's not possible, it should fall back  to a combination of \"Z3\" and other possibilities from the list of requisite. If that's not possible, it should fall back  to a combination of other possibilities from the list of requisite.
	 * @type {Array<Topology>}
	 * @memberof TopologyRequirement
	 */
	Preferred?: Array<Topology>;
	/**
	 * Requisite specifies a list of Topologies, at least one of which the volume must be accessible from.  Taken verbatim from the CSI Spec:  Specifies the list of topologies the provisioned volume MUST be accessible from. This field is OPTIONAL. If TopologyRequirement is specified either requisite or preferred or both MUST be specified.  If requisite is specified, the provisioned volume MUST be accessible from at least one of the requisite topologies.  Given x = number of topologies provisioned volume is accessible from n = number of requisite topologies The CO MUST ensure n >= 1. The SP MUST ensure x >= 1 If x==n, then the SP MUST make the provisioned volume available to all topologies from the list of requisite topologies. If it is unable to do so, the SP MUST fail the CreateVolume call. For example, if a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"} then the provisioned volume MUST be accessible from the \"region\" \"R1\" and the \"zone\" \"Z2\". Similarly, if a volume should be accessible from two zones, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} then the provisioned volume MUST be accessible from the \"region\" \"R1\" and both \"zone\" \"Z2\" and \"zone\" \"Z3\".  If x<n, then the SP SHALL choose x unique topologies from the list of requisite topologies. If it is unable to do so, the SP MUST fail the CreateVolume call. For example, if a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} then the SP may choose to make the provisioned volume available in either the \"zone\" \"Z2\" or the \"zone\" \"Z3\" in the \"region\" \"R1\". Similarly, if a volume should be accessible from two zones, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"}, {\"region\": \"R1\", \"zone\": \"Z4\"} then the provisioned volume MUST be accessible from any combination of two unique topologies: e.g. \"R1/Z2\" and \"R1/Z3\", or \"R1/Z2\" and \"R1/Z4\", or \"R1/Z3\" and \"R1/Z4\".  If x>n, then the SP MUST make the provisioned volume available from all topologies from the list of requisite topologies and MAY choose the remaining x-n unique topologies from the list of all possible topologies. If it is unable to do so, the SP MUST fail the CreateVolume call. For example, if a volume should be accessible from two zones, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"} then the provisioned volume MUST be accessible from the \"region\" \"R1\" and the \"zone\" \"Z2\" and the SP may select the second zone independently, e.g. \"R1/Z4\".
	 * @type {Array<Topology>}
	 * @memberof TopologyRequirement
	 */
	Requisite?: Array<Topology>;
}

/**
 *
 * @export
 * @interface Tournament
 */
export interface Tournament {
	/**
	 *
	 * @type {boolean}
	 * @memberof Tournament
	 */
	anticheat_required?: boolean;
	/**
	 *
	 * @type {any}
	 * @memberof Tournament
	 */
	best_of?: any;
	/**
	 *
	 * @type {boolean}
	 * @memberof Tournament
	 */
	calculate_elo?: boolean;
	/**
	 * DEPRECATED: use tournament_id instead
	 * @type {string}
	 * @memberof Tournament
	 */
	competition_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	cover_image?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Tournament
	 */
	custom?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	description?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	featured_image?: string;
	/**
	 *
	 * @type {Game}
	 * @memberof Tournament
	 */
	game_data?: Game;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	game_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	invite_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	match_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	max_skill?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	membership_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	min_skill?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	number_of_players?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	number_of_players_checkedin?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	number_of_players_joined?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	number_of_players_participants?: number;
	/**
	 *
	 * @type {Organizer}
	 * @memberof Tournament
	 */
	organizer_data?: Organizer;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	prize_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	region?: string;
	/**
	 *
	 * @type {Array<any>}
	 * @memberof Tournament
	 */
	rounds?: Array<any>;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	rule?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	started_at?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	status?: string;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	substitutes_allowed?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	substitutions_allowed?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Tournament
	 */
	team_size?: number;
	/**
	 *
	 * @type {any}
	 * @memberof Tournament
	 */
	total_prize?: any;
	/**
	 *
	 * @type {string}
	 * @memberof Tournament
	 */
	tournament_id?: string;
	/**
	 *
	 * @type {any}
	 * @memberof Tournament
	 */
	voting?: any;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Tournament
	 */
	whitelist_countries?: Array<string>;
}

/**
 *
 * @export
 * @interface TournamentSimple
 */
export interface TournamentSimple {
	/**
	 *
	 * @type {boolean}
	 * @memberof TournamentSimple
	 */
	anticheat_required?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof TournamentSimple
	 */
	custom?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	faceit_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	featured_image?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	game_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	invite_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	match_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	max_skill?: number;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	membership_type?: string;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	min_skill?: number;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	number_of_players?: number;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	number_of_players_checkedin?: number;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	number_of_players_joined?: number;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	number_of_players_participants?: number;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	organizer_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	prize_type?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	region?: string;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	started_at?: number;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	status?: string;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	subscriptions_count?: number;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentSimple
	 */
	team_size?: number;
	/**
	 *
	 * @type {any}
	 * @memberof TournamentSimple
	 */
	total_prize?: any;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentSimple
	 */
	tournament_id?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof TournamentSimple
	 */
	whitelist_countries?: Array<string>;
}

/**
 *
 * @export
 * @interface TournamentTeam
 */
export interface TournamentTeam {
	/**
	 *
	 * @type {string}
	 * @memberof TournamentTeam
	 */
	nickname?: string;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentTeam
	 */
	skill_level?: number;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentTeam
	 */
	subs_done?: number;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentTeam
	 */
	team_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentTeam
	 */
	team_leader?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TournamentTeam
	 */
	team_type?: string;
}

/**
 *
 * @export
 * @interface TournamentTeams
 */
export interface TournamentTeams {
	/**
	 *
	 * @type {Array<TournamentTeam>}
	 * @memberof TournamentTeams
	 */
	checked_in?: Array<TournamentTeam>;
	/**
	 *
	 * @type {Array<TournamentTeam>}
	 * @memberof TournamentTeams
	 */
	finished?: Array<TournamentTeam>;
	/**
	 *
	 * @type {Array<TournamentTeam>}
	 * @memberof TournamentTeams
	 */
	joined?: Array<TournamentTeam>;
	/**
	 *
	 * @type {Array<TournamentTeam>}
	 * @memberof TournamentTeams
	 */
	started?: Array<TournamentTeam>;
}

/**
 *
 * @export
 * @interface TournamentsList
 */
export interface TournamentsList {
	/**
	 *
	 * @type {number}
	 * @memberof TournamentsList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<TournamentSimple>}
	 * @memberof TournamentsList
	 */
	items?: Array<TournamentSimple>;
	/**
	 *
	 * @type {number}
	 * @memberof TournamentsList
	 */
	start?: number;
}

/**
 * Intentionally empty.
 * @export
 * @interface TypeBlock
 */
export type TypeBlock = {};

/**
 * TypeMount contains options for using a volume as a Mount-type volume.
 * @export
 * @interface TypeMount
 */
export interface TypeMount {
	/**
	 * FsType specifies the filesystem type for the mount volume. Optional.
	 * @type {string}
	 * @memberof TypeMount
	 */
	FsType?: string;
	/**
	 * MountFlags defines flags to pass when mounting the volume. Optional.
	 * @type {Array<string>}
	 * @memberof TypeMount
	 */
	MountFlags?: Array<string>;
}

/**
 * UsageData Usage details about the volume. This information is used by the `GET /system/df` endpoint, and omitted in other endpoints.
 * @export
 * @interface UsageData
 */
export interface UsageData {
	/**
	 * The number of containers referencing this volume. This field is set to `-1` if the reference-count is not available.
	 * @type {number}
	 * @memberof UsageData
	 */
	RefCount: number;
	/**
	 * Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the `\"local\"` volume driver. For volumes created with other volume drivers, this field is set to `-1` (\"not available\")
	 * @type {number}
	 * @memberof UsageData
	 */
	Size: number;
}

/**
 *
 * @export
 * @interface UserSearch
 */
export interface UserSearch {
	/**
	 *
	 * @type {string}
	 * @memberof UserSearch
	 */
	avatar?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UserSearch
	 */
	country?: string;
	/**
	 *
	 * @type {Array<GameUserSearch>}
	 * @memberof UserSearch
	 */
	games?: Array<GameUserSearch>;
	/**
	 *
	 * @type {string}
	 * @memberof UserSearch
	 */
	nickname?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UserSearch
	 */
	player_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UserSearch
	 */
	status?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof UserSearch
	 */
	verified?: boolean;
}

/**
 *
 * @export
 * @interface UserSettings
 */
export interface UserSettings {
	/**
	 *
	 * @type {string}
	 * @memberof UserSettings
	 */
	language?: string;
}

/**
 * The UserSimple holds information about a user.
 * @export
 * @interface UserSimple
 */
export interface UserSimple {
	/**
	 * The Avatar of a user
	 * @type {string}
	 * @memberof UserSimple
	 */
	avatar?: string;
	/**
	 * The Country of a user
	 * @type {string}
	 * @memberof UserSimple
	 */
	country?: string;
	/**
	 * The FaceitUrl of a user
	 * @type {string}
	 * @memberof UserSimple
	 */
	faceit_url?: string;
	/**
	 * Deprecated: use memberships instead
	 * @type {string}
	 * @memberof UserSimple
	 */
	membership_type?: string;
	/**
	 * The Memberships of a user
	 * @type {Array<string>}
	 * @memberof UserSimple
	 */
	memberships?: Array<string>;
	/**
	 * The Nickname of a user
	 * @type {string}
	 * @memberof UserSimple
	 */
	nickname?: string;
	/**
	 * The SkillLevel of a user
	 * @type {number}
	 * @memberof UserSimple
	 */
	skill_level?: number;
	/**
	 * The ID of a user
	 * @type {string}
	 * @memberof UserSimple
	 */
	user_id?: string;
}

/**
 *
 * @export
 * @interface UsersSearchList
 */
export interface UsersSearchList {
	/**
	 *
	 * @type {number}
	 * @memberof UsersSearchList
	 */
	end?: number;
	/**
	 *
	 * @type {Array<UserSearch>}
	 * @memberof UsersSearchList
	 */
	items?: Array<UserSearch>;
	/**
	 *
	 * @type {number}
	 * @memberof UsersSearchList
	 */
	start?: number;
}

/**
 *
 * @export
 * @interface Version
 */
export interface Version {
	/**
	 *
	 * @type {number}
	 * @memberof Version
	 */
	Index?: number;
}

/**
 * Volume volume
 * @export
 * @interface Volume
 */
export interface Volume {
	/**
	 *
	 * @type {ClusterVolume}
	 * @memberof Volume
	 */
	ClusterVolume?: ClusterVolume;
	/**
	 * Date/Time the volume was created.
	 * @type {string}
	 * @memberof Volume
	 */
	CreatedAt?: string;
	/**
	 * Name of the volume driver used by the volume.
	 * @type {string}
	 * @memberof Volume
	 */
	Driver: string;
	/**
	 * User-defined key/value metadata.
	 * @type {{ [key: string]: string; }}
	 * @memberof Volume
	 */
	Labels: { [key: string]: string };
	/**
	 * Mount path of the volume on the host.
	 * @type {string}
	 * @memberof Volume
	 */
	Mountpoint: string;
	/**
	 * Name of the volume.
	 * @type {string}
	 * @memberof Volume
	 */
	Name: string;
	/**
	 * The driver specific options used when creating the volume.
	 * @type {{ [key: string]: string; }}
	 * @memberof Volume
	 */
	Options: { [key: string]: string };
	/**
	 * The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
	 * @type {string}
	 * @memberof Volume
	 */
	Scope: string;
	/**
	 * Low-level details about the volume, provided by the volume driver. Details are returned as a map with key/value pairs: `{\"key\":\"value\",\"key2\":\"value2\"}`.  The `Status` field is optional, and is omitted if the volume driver does not support this feature.
	 * @type {{ [key: string]: any; }}
	 * @memberof Volume
	 */
	Status?: { [key: string]: any };
	/**
	 *
	 * @type {UsageData}
	 * @memberof Volume
	 */
	UsageData?: UsageData;
}

/**
 * WaitExitError container waiting error, if any
 * @export
 * @interface WaitExitError
 */
export interface WaitExitError {
	/**
	 * Details of an error
	 * @type {string}
	 * @memberof WaitExitError
	 */
	Message?: string;
}

/**
 * OK response to ContainerWait operation
 * @export
 * @interface WaitResponse
 */
export interface WaitResponse {
	/**
	 *
	 * @type {WaitExitError}
	 * @memberof WaitResponse
	 */
	Error?: WaitExitError;
	/**
	 * Exit code of the container
	 * @type {number}
	 * @memberof WaitResponse
	 */
	StatusCode: number;
}

/**
 * ChampionshipsApi - fetch parameter creator
 * @export
 */
export const ChampionshipsApiFetchParamCreator = (
	configuration?: Configuration,
) => ({
	/**
	 * Retrieve championship details
	 * @summary Retrieve championship details
	 * @param {string} championship_id The id of the championship
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionship(
		championship_id: string,
		expanded?: Array<"organizer" | "game">,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'championship_id' is not null or undefined
		if (championship_id === null || championship_id === undefined) {
			throw new RequiredError(
				"championship_id",
				"Required parameter championship_id was null or undefined when calling getChampionship.",
			);
		}
		const localVarPath = `/championships/{championship_id}`.replace(
			`{${"championship_id"}}`,
			encodeURIComponent(String(championship_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (expanded) {
			localVarQueryParameter["expanded"] = expanded.join(
				COLLECTION_FORMATS["csv"],
			);
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all matches of a championship
	 * @summary Retrieve all matches of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipMatches(
		championship_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'championship_id' is not null or undefined
		if (championship_id === null || championship_id === undefined) {
			throw new RequiredError(
				"championship_id",
				"Required parameter championship_id was null or undefined when calling getChampionshipMatches.",
			);
		}
		const localVarPath = `/championships/{championship_id}/matches`.replace(
			`{${"championship_id"}}`,
			encodeURIComponent(String(championship_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (type !== undefined) {
			localVarQueryParameter["type"] = type;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all results of a championship
	 * @summary Retrieve all results of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipResults(
		championship_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'championship_id' is not null or undefined
		if (championship_id === null || championship_id === undefined) {
			throw new RequiredError(
				"championship_id",
				"Required parameter championship_id was null or undefined when calling getChampionshipResults.",
			);
		}
		const localVarPath = `/championships/{championship_id}/results`.replace(
			`{${"championship_id"}}`,
			encodeURIComponent(String(championship_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all subscriptions of a championship
	 * @summary Retrieve all subscriptions of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipSubscriptions(
		championship_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'championship_id' is not null or undefined
		if (championship_id === null || championship_id === undefined) {
			throw new RequiredError(
				"championship_id",
				"Required parameter championship_id was null or undefined when calling getChampionshipSubscriptions.",
			);
		}
		const localVarPath =
			`/championships/{championship_id}/subscriptions`.replace(
				`{${"championship_id"}}`,
				encodeURIComponent(String(championship_id)),
			);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all championships of a game
	 * @summary Retrieve all championships of a game
	 * @param {string} game The id of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionships(
		game: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game' is not null or undefined
		if (game === null || game === undefined) {
			throw new RequiredError(
				"game",
				"Required parameter game was null or undefined when calling getChampionships.",
			);
		}
		const localVarPath = `/championships`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (type !== undefined) {
			localVarQueryParameter["type"] = type;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * ChampionshipsApi - functional programming interface
 * @export
 */
export const ChampionshipsApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve championship details
	 * @summary Retrieve championship details
	 * @param {string} championship_id The id of the championship
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionship(
		championship_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Championship> {
		const localVarFetchArgs = ChampionshipsApiFetchParamCreator(
			configuration,
		).getChampionship(championship_id, expanded, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all matches of a championship
	 * @summary Retrieve all matches of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipMatches(
		championship_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<MatchList> {
		const localVarFetchArgs = ChampionshipsApiFetchParamCreator(
			configuration,
		).getChampionshipMatches(championship_id, type, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all results of a championship
	 * @summary Retrieve all results of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipResults(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<ChampionshipResultList> {
		const localVarFetchArgs = ChampionshipsApiFetchParamCreator(
			configuration,
		).getChampionshipResults(championship_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all subscriptions of a championship
	 * @summary Retrieve all subscriptions of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipSubscriptions(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (
		fetch?: FetchAPI,
		basePath?: string,
	) => Promise<ChampionshipSubscriptionsList> {
		const localVarFetchArgs = ChampionshipsApiFetchParamCreator(
			configuration,
		).getChampionshipSubscriptions(championship_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all championships of a game
	 * @summary Retrieve all championships of a game
	 * @param {string} game The id of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionships(
		game: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<ChampionshipsList> {
		const localVarFetchArgs = ChampionshipsApiFetchParamCreator(
			configuration,
		).getChampionships(game, type, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * ChampionshipsApi - factory interface
 * @export
 */
export const ChampionshipsApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve championship details
	 * @summary Retrieve championship details
	 * @param {string} championship_id The id of the championship
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionship(
		championship_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	) {
		return ChampionshipsApiFp(configuration).getChampionship(
			championship_id,
			expanded,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all matches of a championship
	 * @summary Retrieve all matches of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipMatches(
		championship_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(configuration).getChampionshipMatches(
			championship_id,
			type,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all results of a championship
	 * @summary Retrieve all results of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipResults(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(configuration).getChampionshipResults(
			championship_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all subscriptions of a championship
	 * @summary Retrieve all subscriptions of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipSubscriptions(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(configuration).getChampionshipSubscriptions(
			championship_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all championships of a game
	 * @summary Retrieve all championships of a game
	 * @param {string} game The id of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionships(
		game: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(configuration).getChampionships(
			game,
			type,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * ChampionshipsApi - object-oriented interface
 * @export
 * @class ChampionshipsApi
 * @extends {BaseAPI}
 */
export class ChampionshipsApi extends BaseAPI {
	/**
	 * Retrieve championship details
	 * @summary Retrieve championship details
	 * @param {string} championship_id The id of the championship
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChampionshipsApi
	 */
	public getChampionship(
		championship_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	) {
		return ChampionshipsApiFp(this.configuration).getChampionship(
			championship_id,
			expanded,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all matches of a championship
	 * @summary Retrieve all matches of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChampionshipsApi
	 */
	public getChampionshipMatches(
		championship_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(this.configuration).getChampionshipMatches(
			championship_id,
			type,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all results of a championship
	 * @summary Retrieve all results of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChampionshipsApi
	 */
	public getChampionshipResults(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(this.configuration).getChampionshipResults(
			championship_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all subscriptions of a championship
	 * @summary Retrieve all subscriptions of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChampionshipsApi
	 */
	public getChampionshipSubscriptions(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(this.configuration).getChampionshipSubscriptions(
			championship_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all championships of a game
	 * @summary Retrieve all championships of a game
	 * @param {string} game The id of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChampionshipsApi
	 */
	public getChampionships(
		game: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return ChampionshipsApiFp(this.configuration).getChampionships(
			game,
			type,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * GamesApi - fetch parameter creator
 * @export
 */
export const GamesApiFetchParamCreator = (configuration?: Configuration) => ({
	/**
	 * Retrieve details of all games on FACEIT
	 * @summary Retrieve details of all games on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getAllGames(offset?: number, limit?: number, options: any = {}): FetchArgs {
		const localVarPath = `/games`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve game details
	 * @summary Retrieve game details
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGame(game_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getGame.",
			);
		}
		const localVarPath = `/games/{game_id}`.replace(
			`{${"game_id"}}`,
			encodeURIComponent(String(game_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve details of all matchmakings of a game on FACEIT
	 * @summary Retrieve details of all matchmakings of a game on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} [region] The region of the matchmakings
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGameMatchmakings(
		game_id: string,
		region?: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getGameMatchmakings.",
			);
		}
		const localVarPath = `/games/{gameId}/matchmakings`.replace(
			`{${"game_id"}}`,
			encodeURIComponent(String(game_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (region !== undefined) {
			localVarQueryParameter["region"] = region;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve the details of the parent game, if the game is region-specific
	 * @summary Retrieve the details of the parent game, if the game is region-specific
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getParentGame(game_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getParentGame.",
			);
		}
		const localVarPath = `/games/{game_id}/parent`.replace(
			`{${"game_id"}}`,
			encodeURIComponent(String(game_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve queue bans on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve queue bans on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueueBans(
		game_id: string,
		queue_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getQueueBans.",
			);
		}
		// verify required parameter 'queue_id' is not null or undefined
		if (queue_id === null || queue_id === undefined) {
			throw new RequiredError(
				"queue_id",
				"Required parameter queue_id was null or undefined when calling getQueueBans.",
			);
		}
		const localVarPath = `/games/{game_id}/queues/{queue_id}/bans`
			.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)))
			.replace(`{${"queue_id"}}`, encodeURIComponent(String(queue_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve details of a queue on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve details of a queue on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueueById(
		game_id: string,
		queue_id: string,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getQueueById.",
			);
		}
		// verify required parameter 'queue_id' is not null or undefined
		if (queue_id === null || queue_id === undefined) {
			throw new RequiredError(
				"queue_id",
				"Required parameter queue_id was null or undefined when calling getQueueById.",
			);
		}
		const localVarPath = `/games/{game_id}/queues/{queue_id}`
			.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)))
			.replace(`{${"queue_id"}}`, encodeURIComponent(String(queue_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve queues by filters on FACEIT. Available only for game developers and queue owners(organizers)
	 * @summary Retrieve queues by filters on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} entity_type The type of the entity
	 * @param {string} entity_id The id of the entity
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueuesByEntityFilters(
		game_id: string,
		entity_type: string,
		entity_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getQueuesByEntityFilters.",
			);
		}
		// verify required parameter 'entity_type' is not null or undefined
		if (entity_type === null || entity_type === undefined) {
			throw new RequiredError(
				"entity_type",
				"Required parameter entity_type was null or undefined when calling getQueuesByEntityFilters.",
			);
		}
		// verify required parameter 'entity_id' is not null or undefined
		if (entity_id === null || entity_id === undefined) {
			throw new RequiredError(
				"entity_id",
				"Required parameter entity_id was null or undefined when calling getQueuesByEntityFilters.",
			);
		}
		const localVarPath = `/games/{game_id}/queues`.replace(
			`{${"game_id"}}`,
			encodeURIComponent(String(game_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (entity_type !== undefined) {
			localVarQueryParameter["entity_type"] = entity_type;
		}

		if (entity_id !== undefined) {
			localVarQueryParameter["entity_id"] = entity_id;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve queues by region on FACEIT. Available only for game developers
	 * @summary Retrieve queues by region on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} region_id The id of the region
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueuesByRegion(
		game_id: string,
		region_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getQueuesByRegion.",
			);
		}
		// verify required parameter 'region_id' is not null or undefined
		if (region_id === null || region_id === undefined) {
			throw new RequiredError(
				"region_id",
				"Required parameter region_id was null or undefined when calling getQueuesByRegion.",
			);
		}
		const localVarPath = `/games/{game_id}/regions/{region_id}/queues`
			.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)))
			.replace(`{${"region_id"}}`, encodeURIComponent(String(region_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * GamesApi - functional programming interface
 * @export
 */
export const GamesApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve details of all games on FACEIT
	 * @summary Retrieve details of all games on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getAllGames(
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<GamesList> {
		const localVarFetchArgs = GamesApiFetchParamCreator(
			configuration,
		).getAllGames(offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve game details
	 * @summary Retrieve game details
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGame(
		game_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Game> {
		const localVarFetchArgs = GamesApiFetchParamCreator(configuration).getGame(
			game_id,
			options,
		);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve details of all matchmakings of a game on FACEIT
	 * @summary Retrieve details of all matchmakings of a game on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} [region] The region of the matchmakings
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGameMatchmakings(
		game_id: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<MatchmakingList> {
		const localVarFetchArgs = GamesApiFetchParamCreator(
			configuration,
		).getGameMatchmakings(game_id, region, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve the details of the parent game, if the game is region-specific
	 * @summary Retrieve the details of the parent game, if the game is region-specific
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getParentGame(
		game_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Game> {
		const localVarFetchArgs = GamesApiFetchParamCreator(
			configuration,
		).getParentGame(game_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve queue bans on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve queue bans on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueueBans(
		game_id: string,
		queue_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<QueueBansList> {
		const localVarFetchArgs = GamesApiFetchParamCreator(
			configuration,
		).getQueueBans(game_id, queue_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve details of a queue on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve details of a queue on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueueById(
		game_id: string,
		queue_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Queue> {
		const localVarFetchArgs = GamesApiFetchParamCreator(
			configuration,
		).getQueueById(game_id, queue_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve queues by filters on FACEIT. Available only for game developers and queue owners(organizers)
	 * @summary Retrieve queues by filters on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} entity_type The type of the entity
	 * @param {string} entity_id The id of the entity
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueuesByEntityFilters(
		game_id: string,
		entity_type: string,
		entity_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<QueuesList> {
		const localVarFetchArgs = GamesApiFetchParamCreator(
			configuration,
		).getQueuesByEntityFilters(
			game_id,
			entity_type,
			entity_id,
			offset,
			limit,
			options,
		);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve queues by region on FACEIT. Available only for game developers
	 * @summary Retrieve queues by region on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} region_id The id of the region
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueuesByRegion(
		game_id: string,
		region_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<QueuesList> {
		const localVarFetchArgs = GamesApiFetchParamCreator(
			configuration,
		).getQueuesByRegion(game_id, region_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * GamesApi - factory interface
 * @export
 */
export const GamesApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve details of all games on FACEIT
	 * @summary Retrieve details of all games on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getAllGames(offset?: number, limit?: number, options?: any) {
		return GamesApiFp(configuration).getAllGames(
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve game details
	 * @summary Retrieve game details
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGame(game_id: string, options?: any) {
		return GamesApiFp(configuration).getGame(game_id, options)(fetch, basePath);
	},
	/**
	 * Retrieve details of all matchmakings of a game on FACEIT
	 * @summary Retrieve details of all matchmakings of a game on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} [region] The region of the matchmakings
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGameMatchmakings(
		game_id: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(configuration).getGameMatchmakings(
			game_id,
			region,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve the details of the parent game, if the game is region-specific
	 * @summary Retrieve the details of the parent game, if the game is region-specific
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getParentGame(game_id: string, options?: any) {
		return GamesApiFp(configuration).getParentGame(game_id, options)(
			fetch,
			basePath,
		);
	},
	/**
	 * Retrieve queue bans on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve queue bans on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueueBans(
		game_id: string,
		queue_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(configuration).getQueueBans(
			game_id,
			queue_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve details of a queue on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve details of a queue on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueueById(game_id: string, queue_id: string, options?: any) {
		return GamesApiFp(configuration).getQueueById(
			game_id,
			queue_id,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve queues by filters on FACEIT. Available only for game developers and queue owners(organizers)
	 * @summary Retrieve queues by filters on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} entity_type The type of the entity
	 * @param {string} entity_id The id of the entity
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueuesByEntityFilters(
		game_id: string,
		entity_type: string,
		entity_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(configuration).getQueuesByEntityFilters(
			game_id,
			entity_type,
			entity_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve queues by region on FACEIT. Available only for game developers
	 * @summary Retrieve queues by region on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} region_id The id of the region
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getQueuesByRegion(
		game_id: string,
		region_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(configuration).getQueuesByRegion(
			game_id,
			region_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * GamesApi - object-oriented interface
 * @export
 * @class GamesApi
 * @extends {BaseAPI}
 */
export class GamesApi extends BaseAPI {
	/**
	 * Retrieve details of all games on FACEIT
	 * @summary Retrieve details of all games on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getAllGames(offset?: number, limit?: number, options?: any) {
		return GamesApiFp(this.configuration).getAllGames(
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve game details
	 * @summary Retrieve game details
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getGame(game_id: string, options?: any) {
		return GamesApiFp(this.configuration).getGame(game_id, options)(
			this.fetch,
			this.basePath,
		);
	}

	/**
	 * Retrieve details of all matchmakings of a game on FACEIT
	 * @summary Retrieve details of all matchmakings of a game on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} [region] The region of the matchmakings
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getGameMatchmakings(
		game_id: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(this.configuration).getGameMatchmakings(
			game_id,
			region,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve the details of the parent game, if the game is region-specific
	 * @summary Retrieve the details of the parent game, if the game is region-specific
	 * @param {string} game_id The id of the game
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getParentGame(game_id: string, options?: any) {
		return GamesApiFp(this.configuration).getParentGame(game_id, options)(
			this.fetch,
			this.basePath,
		);
	}

	/**
	 * Retrieve queue bans on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve queue bans on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getQueueBans(
		game_id: string,
		queue_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(this.configuration).getQueueBans(
			game_id,
			queue_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve details of a queue on FACEIT. Available only for game or queue owners(organizers)
	 * @summary Retrieve details of a queue on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} queue_id The id of the queue
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getQueueById(game_id: string, queue_id: string, options?: any) {
		return GamesApiFp(this.configuration).getQueueById(
			game_id,
			queue_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve queues by filters on FACEIT. Available only for game developers and queue owners(organizers)
	 * @summary Retrieve queues by filters on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} entity_type The type of the entity
	 * @param {string} entity_id The id of the entity
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getQueuesByEntityFilters(
		game_id: string,
		entity_type: string,
		entity_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(this.configuration).getQueuesByEntityFilters(
			game_id,
			entity_type,
			entity_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve queues by region on FACEIT. Available only for game developers
	 * @summary Retrieve queues by region on FACEIT
	 * @param {string} game_id The id of the game
	 * @param {string} region_id The id of the region
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GamesApi
	 */
	public getQueuesByRegion(
		game_id: string,
		region_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return GamesApiFp(this.configuration).getQueuesByRegion(
			game_id,
			region_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * HubsApi - fetch parameter creator
 * @export
 */
export const HubsApiFetchParamCreator = (configuration?: Configuration) => ({
	/**
	 * Retrieve hub details
	 * @summary Retrieve hub details
	 * @param {string} hub_id The id of the hub
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHub(
		hub_id: string,
		expanded?: Array<"organizer" | "game">,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHub.",
			);
		}
		const localVarPath = `/hubs/{hub_id}`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (expanded) {
			localVarQueryParameter["expanded"] = expanded.join(
				COLLECTION_FORMATS["csv"],
			);
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all matches of a hub
	 * @summary Retrieve all matches of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubMatches(
		hub_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubMatches.",
			);
		}
		const localVarPath = `/hubs/{hub_id}/matches`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (type !== undefined) {
			localVarQueryParameter["type"] = type;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all members of a hub
	 * @summary Retrieve all members of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubMembers(
		hub_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubMembers.",
			);
		}
		const localVarPath = `/hubs/{hub_id}/members`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all roles members can have in a hub
	 * @summary Retrieve all roles members can have in a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRoles(
		hub_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubRoles.",
			);
		}
		const localVarPath = `/hubs/{hub_id}/roles`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve rules of a hub
	 * @summary Retrieve rules of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRules(hub_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubRules.",
			);
		}
		const localVarPath = `/hubs/{hub_id}/rules`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve statistics of a hub
	 * @summary Retrieve statistics of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubStats(
		hub_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubStats.",
			);
		}
		const localVarPath = `/hubs/{hub_id}/stats`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * HubsApi - functional programming interface
 * @export
 */
export const HubsApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve hub details
	 * @summary Retrieve hub details
	 * @param {string} hub_id The id of the hub
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHub(
		hub_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Hub> {
		const localVarFetchArgs = HubsApiFetchParamCreator(configuration).getHub(
			hub_id,
			expanded,
			options,
		);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all matches of a hub
	 * @summary Retrieve all matches of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubMatches(
		hub_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<MatchList> {
		const localVarFetchArgs = HubsApiFetchParamCreator(
			configuration,
		).getHubMatches(hub_id, type, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all members of a hub
	 * @summary Retrieve all members of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubMembers(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<HubMembers> {
		const localVarFetchArgs = HubsApiFetchParamCreator(
			configuration,
		).getHubMembers(hub_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all roles members can have in a hub
	 * @summary Retrieve all roles members can have in a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRoles(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<RolesList> {
		const localVarFetchArgs = HubsApiFetchParamCreator(
			configuration,
		).getHubRoles(hub_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve rules of a hub
	 * @summary Retrieve rules of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRules(
		hub_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Rules> {
		const localVarFetchArgs = HubsApiFetchParamCreator(
			configuration,
		).getHubRules(hub_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve statistics of a hub
	 * @summary Retrieve statistics of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubStats(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<HubStats> {
		const localVarFetchArgs = HubsApiFetchParamCreator(
			configuration,
		).getHubStats(hub_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * HubsApi - factory interface
 * @export
 */
export const HubsApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve hub details
	 * @summary Retrieve hub details
	 * @param {string} hub_id The id of the hub
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHub(
		hub_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	) {
		return HubsApiFp(configuration).getHub(
			hub_id,
			expanded,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all matches of a hub
	 * @summary Retrieve all matches of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubMatches(
		hub_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return HubsApiFp(configuration).getHubMatches(
			hub_id,
			type,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all members of a hub
	 * @summary Retrieve all members of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubMembers(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return HubsApiFp(configuration).getHubMembers(
			hub_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all roles members can have in a hub
	 * @summary Retrieve all roles members can have in a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRoles(hub_id: string, offset?: number, limit?: number, options?: any) {
		return HubsApiFp(configuration).getHubRoles(
			hub_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve rules of a hub
	 * @summary Retrieve rules of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRules(hub_id: string, options?: any) {
		return HubsApiFp(configuration).getHubRules(hub_id, options)(
			fetch,
			basePath,
		);
	},
	/**
	 * Retrieve statistics of a hub
	 * @summary Retrieve statistics of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubStats(hub_id: string, offset?: number, limit?: number, options?: any) {
		return HubsApiFp(configuration).getHubStats(
			hub_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * HubsApi - object-oriented interface
 * @export
 * @class HubsApi
 * @extends {BaseAPI}
 */
export class HubsApi extends BaseAPI {
	/**
	 * Retrieve hub details
	 * @summary Retrieve hub details
	 * @param {string} hub_id The id of the hub
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HubsApi
	 */
	public getHub(
		hub_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	) {
		return HubsApiFp(this.configuration).getHub(
			hub_id,
			expanded,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all matches of a hub
	 * @summary Retrieve all matches of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of matches to return. Can be all(default), upcoming, ongoing or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HubsApi
	 */
	public getHubMatches(
		hub_id: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return HubsApiFp(this.configuration).getHubMatches(
			hub_id,
			type,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all members of a hub
	 * @summary Retrieve all members of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HubsApi
	 */
	public getHubMembers(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return HubsApiFp(this.configuration).getHubMembers(
			hub_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all roles members can have in a hub
	 * @summary Retrieve all roles members can have in a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HubsApi
	 */
	public getHubRoles(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return HubsApiFp(this.configuration).getHubRoles(
			hub_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve rules of a hub
	 * @summary Retrieve rules of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HubsApi
	 */
	public getHubRules(hub_id: string, options?: any) {
		return HubsApiFp(this.configuration).getHubRules(hub_id, options)(
			this.fetch,
			this.basePath,
		);
	}

	/**
	 * Retrieve statistics of a hub
	 * @summary Retrieve statistics of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HubsApi
	 */
	public getHubStats(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return HubsApiFp(this.configuration).getHubStats(
			hub_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * LeaderboardsApi - fetch parameter creator
 * @export
 */
export const LeaderboardsApiFetchParamCreator = (
	configuration?: Configuration,
) => ({
	/**
	 * Retrieve group ranking of a championship
	 * @summary Retrieve group ranking of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} group A group of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipGroupRanking(
		championship_id: string,
		group: number,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'championship_id' is not null or undefined
		if (championship_id === null || championship_id === undefined) {
			throw new RequiredError(
				"championship_id",
				"Required parameter championship_id was null or undefined when calling getChampionshipGroupRanking.",
			);
		}
		// verify required parameter 'group' is not null or undefined
		if (group === null || group === undefined) {
			throw new RequiredError(
				"group",
				"Required parameter group was null or undefined when calling getChampionshipGroupRanking.",
			);
		}
		const localVarPath =
			`/leaderboards/championships/{championship_id}/groups/{group}`
				.replace(
					`{${"championship_id"}}`,
					encodeURIComponent(String(championship_id)),
				)
				.replace(`{${"group"}}`, encodeURIComponent(String(group)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all leaderboards of a championship
	 * @summary Retrieve all leaderboards of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipLeaderboards(
		championship_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'championship_id' is not null or undefined
		if (championship_id === null || championship_id === undefined) {
			throw new RequiredError(
				"championship_id",
				"Required parameter championship_id was null or undefined when calling getChampionshipLeaderboards.",
			);
		}
		const localVarPath =
			`/leaderboards/championships/{championship_id}`.replace(
				`{${"championship_id"}}`,
				encodeURIComponent(String(championship_id)),
			);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all leaderboards of a hub
	 * @summary Retrieve all leaderboards of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubLeaderboards(
		hub_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubLeaderboards.",
			);
		}
		const localVarPath = `/leaderboards/hubs/{hub_id}`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all time ranking of a hub
	 * @summary Retrieve all time ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRanking(
		hub_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubRanking.",
			);
		}
		const localVarPath = `/leaderboards/hubs/{hub_id}/general`.replace(
			`{${"hub_id"}}`,
			encodeURIComponent(String(hub_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve seasonal ranking of a hub
	 * @summary Retrieve seasonal ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} season A season of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubSeasonRanking(
		hub_id: string,
		season: number,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'hub_id' is not null or undefined
		if (hub_id === null || hub_id === undefined) {
			throw new RequiredError(
				"hub_id",
				"Required parameter hub_id was null or undefined when calling getHubSeasonRanking.",
			);
		}
		// verify required parameter 'season' is not null or undefined
		if (season === null || season === undefined) {
			throw new RequiredError(
				"season",
				"Required parameter season was null or undefined when calling getHubSeasonRanking.",
			);
		}
		const localVarPath = `/leaderboards/hubs/{hub_id}/seasons/{season}`
			.replace(`{${"hub_id"}}`, encodeURIComponent(String(hub_id)))
			.replace(`{${"season"}}`, encodeURIComponent(String(season)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve ranking from a leaderboard id
	 * @summary Retrieve ranking from a leaderboard id
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeaderboard(
		leaderboard_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'leaderboard_id' is not null or undefined
		if (leaderboard_id === null || leaderboard_id === undefined) {
			throw new RequiredError(
				"leaderboard_id",
				"Required parameter leaderboard_id was null or undefined when calling getLeaderboard.",
			);
		}
		const localVarPath = `/leaderboards/{leaderboard_id}`.replace(
			`{${"leaderboard_id"}}`,
			encodeURIComponent(String(leaderboard_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve a players ranking in a leaderboard
	 * @summary Retrieve a players ranking in a leaderboard
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerRankingInLeaderboard(
		leaderboard_id: string,
		player_id: string,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'leaderboard_id' is not null or undefined
		if (leaderboard_id === null || leaderboard_id === undefined) {
			throw new RequiredError(
				"leaderboard_id",
				"Required parameter leaderboard_id was null or undefined when calling getPlayerRankingInLeaderboard.",
			);
		}
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerRankingInLeaderboard.",
			);
		}
		const localVarPath = `/leaderboards/{leaderboard_id}/players/{player_id}`
			.replace(
				`{${"leaderboard_id"}}`,
				encodeURIComponent(String(leaderboard_id)),
			)
			.replace(`{${"player_id"}}`, encodeURIComponent(String(player_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * LeaderboardsApi - functional programming interface
 * @export
 */
export const LeaderboardsApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve group ranking of a championship
	 * @summary Retrieve group ranking of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} group A group of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipGroupRanking(
		championship_id: string,
		group: number,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<EntityRanking> {
		const localVarFetchArgs = LeaderboardsApiFetchParamCreator(
			configuration,
		).getChampionshipGroupRanking(
			championship_id,
			group,
			offset,
			limit,
			options,
		);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all leaderboards of a championship
	 * @summary Retrieve all leaderboards of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipLeaderboards(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardsList> {
		const localVarFetchArgs = LeaderboardsApiFetchParamCreator(
			configuration,
		).getChampionshipLeaderboards(championship_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all leaderboards of a hub
	 * @summary Retrieve all leaderboards of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubLeaderboards(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardsList> {
		const localVarFetchArgs = LeaderboardsApiFetchParamCreator(
			configuration,
		).getHubLeaderboards(hub_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all time ranking of a hub
	 * @summary Retrieve all time ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRanking(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<EntityRanking> {
		const localVarFetchArgs = LeaderboardsApiFetchParamCreator(
			configuration,
		).getHubRanking(hub_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve seasonal ranking of a hub
	 * @summary Retrieve seasonal ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} season A season of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubSeasonRanking(
		hub_id: string,
		season: number,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<EntityRanking> {
		const localVarFetchArgs = LeaderboardsApiFetchParamCreator(
			configuration,
		).getHubSeasonRanking(hub_id, season, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve ranking from a leaderboard id
	 * @summary Retrieve ranking from a leaderboard id
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeaderboard(
		leaderboard_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<EntityRanking> {
		const localVarFetchArgs = LeaderboardsApiFetchParamCreator(
			configuration,
		).getLeaderboard(leaderboard_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve a players ranking in a leaderboard
	 * @summary Retrieve a players ranking in a leaderboard
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerRankingInLeaderboard(
		leaderboard_id: string,
		player_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Ranking> {
		const localVarFetchArgs = LeaderboardsApiFetchParamCreator(
			configuration,
		).getPlayerRankingInLeaderboard(leaderboard_id, player_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * LeaderboardsApi - factory interface
 * @export
 */
export const LeaderboardsApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve group ranking of a championship
	 * @summary Retrieve group ranking of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} group A group of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipGroupRanking(
		championship_id: string,
		group: number,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(configuration).getChampionshipGroupRanking(
			championship_id,
			group,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all leaderboards of a championship
	 * @summary Retrieve all leaderboards of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getChampionshipLeaderboards(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(configuration).getChampionshipLeaderboards(
			championship_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all leaderboards of a hub
	 * @summary Retrieve all leaderboards of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubLeaderboards(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(configuration).getHubLeaderboards(
			hub_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all time ranking of a hub
	 * @summary Retrieve all time ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubRanking(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(configuration).getHubRanking(
			hub_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve seasonal ranking of a hub
	 * @summary Retrieve seasonal ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} season A season of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getHubSeasonRanking(
		hub_id: string,
		season: number,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(configuration).getHubSeasonRanking(
			hub_id,
			season,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve ranking from a leaderboard id
	 * @summary Retrieve ranking from a leaderboard id
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeaderboard(
		leaderboard_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(configuration).getLeaderboard(
			leaderboard_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve a players ranking in a leaderboard
	 * @summary Retrieve a players ranking in a leaderboard
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerRankingInLeaderboard(
		leaderboard_id: string,
		player_id: string,
		options?: any,
	) {
		return LeaderboardsApiFp(configuration).getPlayerRankingInLeaderboard(
			leaderboard_id,
			player_id,
			options,
		)(fetch, basePath);
	},
});

/**
 * LeaderboardsApi - object-oriented interface
 * @export
 * @class LeaderboardsApi
 * @extends {BaseAPI}
 */
export class LeaderboardsApi extends BaseAPI {
	/**
	 * Retrieve group ranking of a championship
	 * @summary Retrieve group ranking of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} group A group of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaderboardsApi
	 */
	public getChampionshipGroupRanking(
		championship_id: string,
		group: number,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(this.configuration).getChampionshipGroupRanking(
			championship_id,
			group,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all leaderboards of a championship
	 * @summary Retrieve all leaderboards of a championship
	 * @param {string} championship_id The id of the championship
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaderboardsApi
	 */
	public getChampionshipLeaderboards(
		championship_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(this.configuration).getChampionshipLeaderboards(
			championship_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all leaderboards of a hub
	 * @summary Retrieve all leaderboards of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaderboardsApi
	 */
	public getHubLeaderboards(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(this.configuration).getHubLeaderboards(
			hub_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all time ranking of a hub
	 * @summary Retrieve all time ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaderboardsApi
	 */
	public getHubRanking(
		hub_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(this.configuration).getHubRanking(
			hub_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve seasonal ranking of a hub
	 * @summary Retrieve seasonal ranking of a hub
	 * @param {string} hub_id The id of the hub
	 * @param {number} season A season of the hub
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaderboardsApi
	 */
	public getHubSeasonRanking(
		hub_id: string,
		season: number,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(this.configuration).getHubSeasonRanking(
			hub_id,
			season,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve ranking from a leaderboard id
	 * @summary Retrieve ranking from a leaderboard id
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaderboardsApi
	 */
	public getLeaderboard(
		leaderboard_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return LeaderboardsApiFp(this.configuration).getLeaderboard(
			leaderboard_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve a players ranking in a leaderboard
	 * @summary Retrieve a players ranking in a leaderboard
	 * @param {string} leaderboard_id The id of the leaderboard
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaderboardsApi
	 */
	public getPlayerRankingInLeaderboard(
		leaderboard_id: string,
		player_id: string,
		options?: any,
	) {
		return LeaderboardsApiFp(this.configuration).getPlayerRankingInLeaderboard(
			leaderboard_id,
			player_id,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * LeaguesApi - fetch parameter creator
 * @export
 */
export const LeaguesApiFetchParamCreator = (configuration?: Configuration) => ({
	/**
	 * Retrieve details of a league of a matchmaking on FACEIT
	 * @summary Retrieve details of a league of a matchmaking on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeagueById(league_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'league_id' is not null or undefined
		if (league_id === null || league_id === undefined) {
			throw new RequiredError(
				"league_id",
				"Required parameter league_id was null or undefined when calling getLeagueById.",
			);
		}
		const localVarPath = `/leagues/{league_id}`.replace(
			`{${"league_id"}}`,
			encodeURIComponent(String(league_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve details of a season of a league on FACEIT
	 * @summary Retrieve details of a season of a league on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeagueSeason(
		league_id: string,
		season_id: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'league_id' is not null or undefined
		if (league_id === null || league_id === undefined) {
			throw new RequiredError(
				"league_id",
				"Required parameter league_id was null or undefined when calling getLeagueSeason.",
			);
		}
		// verify required parameter 'season_id' is not null or undefined
		if (season_id === null || season_id === undefined) {
			throw new RequiredError(
				"season_id",
				"Required parameter season_id was null or undefined when calling getLeagueSeason.",
			);
		}
		const localVarPath = `/leagues/{league_id}/seasons/{season_id}`
			.replace(`{${"league_id"}}`, encodeURIComponent(String(league_id)))
			.replace(`{${"season_id"}}`, encodeURIComponent(String(season_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve details of a player for a given league and season on FACEIT
	 * @summary Retrieve details of a player for a given league and season on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerForLeagueSeason(
		league_id: string,
		season_id: number,
		player_id: string,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'league_id' is not null or undefined
		if (league_id === null || league_id === undefined) {
			throw new RequiredError(
				"league_id",
				"Required parameter league_id was null or undefined when calling getPlayerForLeagueSeason.",
			);
		}
		// verify required parameter 'season_id' is not null or undefined
		if (season_id === null || season_id === undefined) {
			throw new RequiredError(
				"season_id",
				"Required parameter season_id was null or undefined when calling getPlayerForLeagueSeason.",
			);
		}
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerForLeagueSeason.",
			);
		}
		const localVarPath =
			`/leagues/{league_id}/seasons/{season_id}/players/{player_id}`
				.replace(`{${"league_id"}}`, encodeURIComponent(String(league_id)))
				.replace(`{${"season_id"}}`, encodeURIComponent(String(season_id)))
				.replace(`{${"player_id"}}`, encodeURIComponent(String(player_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * LeaguesApi - functional programming interface
 * @export
 */
export const LeaguesApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve details of a league of a matchmaking on FACEIT
	 * @summary Retrieve details of a league of a matchmaking on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeagueById(
		league_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<League> {
		const localVarFetchArgs = LeaguesApiFetchParamCreator(
			configuration,
		).getLeagueById(league_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve details of a season of a league on FACEIT
	 * @summary Retrieve details of a season of a league on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeagueSeason(
		league_id: string,
		season_id: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<SeasonDetailed> {
		const localVarFetchArgs = LeaguesApiFetchParamCreator(
			configuration,
		).getLeagueSeason(league_id, season_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve details of a player for a given league and season on FACEIT
	 * @summary Retrieve details of a player for a given league and season on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerForLeagueSeason(
		league_id: string,
		season_id: number,
		player_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerInLeague> {
		const localVarFetchArgs = LeaguesApiFetchParamCreator(
			configuration,
		).getPlayerForLeagueSeason(league_id, season_id, player_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * LeaguesApi - factory interface
 * @export
 */
export const LeaguesApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve details of a league of a matchmaking on FACEIT
	 * @summary Retrieve details of a league of a matchmaking on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeagueById(league_id: string, options?: any) {
		return LeaguesApiFp(configuration).getLeagueById(league_id, options)(
			fetch,
			basePath,
		);
	},
	/**
	 * Retrieve details of a season of a league on FACEIT
	 * @summary Retrieve details of a season of a league on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLeagueSeason(league_id: string, season_id: number, options?: any) {
		return LeaguesApiFp(configuration).getLeagueSeason(
			league_id,
			season_id,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve details of a player for a given league and season on FACEIT
	 * @summary Retrieve details of a player for a given league and season on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerForLeagueSeason(
		league_id: string,
		season_id: number,
		player_id: string,
		options?: any,
	) {
		return LeaguesApiFp(configuration).getPlayerForLeagueSeason(
			league_id,
			season_id,
			player_id,
			options,
		)(fetch, basePath);
	},
});

/**
 * LeaguesApi - object-oriented interface
 * @export
 * @class LeaguesApi
 * @extends {BaseAPI}
 */
export class LeaguesApi extends BaseAPI {
	/**
	 * Retrieve details of a league of a matchmaking on FACEIT
	 * @summary Retrieve details of a league of a matchmaking on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaguesApi
	 */
	public getLeagueById(league_id: string, options?: any) {
		return LeaguesApiFp(this.configuration).getLeagueById(league_id, options)(
			this.fetch,
			this.basePath,
		);
	}

	/**
	 * Retrieve details of a season of a league on FACEIT
	 * @summary Retrieve details of a season of a league on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaguesApi
	 */
	public getLeagueSeason(league_id: string, season_id: number, options?: any) {
		return LeaguesApiFp(this.configuration).getLeagueSeason(
			league_id,
			season_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve details of a player for a given league and season on FACEIT
	 * @summary Retrieve details of a player for a given league and season on FACEIT
	 * @param {string} league_id The id of the league
	 * @param {number} season_id The id of the season
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LeaguesApi
	 */
	public getPlayerForLeagueSeason(
		league_id: string,
		season_id: number,
		player_id: string,
		options?: any,
	) {
		return LeaguesApiFp(this.configuration).getPlayerForLeagueSeason(
			league_id,
			season_id,
			player_id,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * MatchesApi - fetch parameter creator
 * @export
 */
export const MatchesApiFetchParamCreator = (configuration?: Configuration) => ({
	/**
	 * Retrieve match details
	 * @summary Retrieve match details
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatch(match_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'match_id' is not null or undefined
		if (match_id === null || match_id === undefined) {
			throw new RequiredError(
				"match_id",
				"Required parameter match_id was null or undefined when calling getMatch.",
			);
		}
		const localVarPath = `/matches/{match_id}`.replace(
			`{${"match_id"}}`,
			encodeURIComponent(String(match_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve statistics of a match
	 * @summary Retrieve statistics of a match
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatchStats(match_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'match_id' is not null or undefined
		if (match_id === null || match_id === undefined) {
			throw new RequiredError(
				"match_id",
				"Required parameter match_id was null or undefined when calling getMatchStats.",
			);
		}
		const localVarPath = `/matches/{match_id}/stats`.replace(
			`{${"match_id"}}`,
			encodeURIComponent(String(match_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * MatchesApi - functional programming interface
 * @export
 */
export const MatchesApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve match details
	 * @summary Retrieve match details
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatch(
		match_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Match> {
		const localVarFetchArgs = MatchesApiFetchParamCreator(
			configuration,
		).getMatch(match_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve statistics of a match
	 * @summary Retrieve statistics of a match
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatchStats(
		match_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<MatchStats> {
		const localVarFetchArgs = MatchesApiFetchParamCreator(
			configuration,
		).getMatchStats(match_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * MatchesApi - factory interface
 * @export
 */
export const MatchesApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve match details
	 * @summary Retrieve match details
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatch(match_id: string, options?: any) {
		return MatchesApiFp(configuration).getMatch(match_id, options)(
			fetch,
			basePath,
		);
	},
	/**
	 * Retrieve statistics of a match
	 * @summary Retrieve statistics of a match
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatchStats(match_id: string, options?: any) {
		return MatchesApiFp(configuration).getMatchStats(match_id, options)(
			fetch,
			basePath,
		);
	},
});

/**
 * MatchesApi - object-oriented interface
 * @export
 * @class MatchesApi
 * @extends {BaseAPI}
 */
export class MatchesApi extends BaseAPI {
	/**
	 * Retrieve match details
	 * @summary Retrieve match details
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof MatchesApi
	 */
	public getMatch(match_id: string, options?: any) {
		return MatchesApiFp(this.configuration).getMatch(match_id, options)(
			this.fetch,
			this.basePath,
		);
	}

	/**
	 * Retrieve statistics of a match
	 * @summary Retrieve statistics of a match
	 * @param {string} match_id The id of the match
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof MatchesApi
	 */
	public getMatchStats(match_id: string, options?: any) {
		return MatchesApiFp(this.configuration).getMatchStats(match_id, options)(
			this.fetch,
			this.basePath,
		);
	}
}

/**
 * MatchmakingsApi - fetch parameter creator
 * @export
 */
export const MatchmakingsApiFetchParamCreator = (
	configuration?: Configuration,
) => ({
	/**
	 * Retrieve details of a matchmaking of a game on FACEIT
	 * @summary Retrieve details of a matchmaking of a game on FACEIT
	 * @param {string} matchmaking_id The id of the matchmaking
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatchmaking(matchmaking_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'matchmaking_id' is not null or undefined
		if (matchmaking_id === null || matchmaking_id === undefined) {
			throw new RequiredError(
				"matchmaking_id",
				"Required parameter matchmaking_id was null or undefined when calling getMatchmaking.",
			);
		}
		const localVarPath = `/matchmakings/{matchmaking_id}`.replace(
			`{${"matchmaking_id"}}`,
			encodeURIComponent(String(matchmaking_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * MatchmakingsApi - functional programming interface
 * @export
 */
export const MatchmakingsApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve details of a matchmaking of a game on FACEIT
	 * @summary Retrieve details of a matchmaking of a game on FACEIT
	 * @param {string} matchmaking_id The id of the matchmaking
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatchmaking(
		matchmaking_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Matchmaking> {
		const localVarFetchArgs = MatchmakingsApiFetchParamCreator(
			configuration,
		).getMatchmaking(matchmaking_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * MatchmakingsApi - factory interface
 * @export
 */
export const MatchmakingsApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve details of a matchmaking of a game on FACEIT
	 * @summary Retrieve details of a matchmaking of a game on FACEIT
	 * @param {string} matchmaking_id The id of the matchmaking
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getMatchmaking(matchmaking_id: string, options?: any) {
		return MatchmakingsApiFp(configuration).getMatchmaking(
			matchmaking_id,
			options,
		)(fetch, basePath);
	},
});

/**
 * MatchmakingsApi - object-oriented interface
 * @export
 * @class MatchmakingsApi
 * @extends {BaseAPI}
 */
export class MatchmakingsApi extends BaseAPI {
	/**
	 * Retrieve details of a matchmaking of a game on FACEIT
	 * @summary Retrieve details of a matchmaking of a game on FACEIT
	 * @param {string} matchmaking_id The id of the matchmaking
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof MatchmakingsApi
	 */
	public getMatchmaking(matchmaking_id: string, options?: any) {
		return MatchmakingsApiFp(this.configuration).getMatchmaking(
			matchmaking_id,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * OrganizersApi - fetch parameter creator
 * @export
 */
export const OrganizersApiFetchParamCreator = (
	configuration?: Configuration,
) => ({
	/**
	 * Retrieve organizer details
	 * @summary Retrieve organizer details
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizer(organizer_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'organizer_id' is not null or undefined
		if (organizer_id === null || organizer_id === undefined) {
			throw new RequiredError(
				"organizer_id",
				"Required parameter organizer_id was null or undefined when calling getOrganizer.",
			);
		}
		const localVarPath = `/organizers/{organizer_id}`.replace(
			`{${"organizer_id"}}`,
			encodeURIComponent(String(organizer_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve organizer details from name
	 * @summary Retrieve organizer details from name
	 * @param {string} name The name of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerByName(name: string, options: any = {}): FetchArgs {
		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new RequiredError(
				"name",
				"Required parameter name was null or undefined when calling getOrganizerByName.",
			);
		}
		const localVarPath = `/organizers`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (name !== undefined) {
			localVarQueryParameter["name"] = name;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all championships of an organizer
	 * @summary Retrieve all championships of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerChampionships(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'organizer_id' is not null or undefined
		if (organizer_id === null || organizer_id === undefined) {
			throw new RequiredError(
				"organizer_id",
				"Required parameter organizer_id was null or undefined when calling getOrganizerChampionships.",
			);
		}
		const localVarPath = `/organizers/{organizer_id}/championships`.replace(
			`{${"organizer_id"}}`,
			encodeURIComponent(String(organizer_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all games an organizer is involved with
	 * @summary Retrieve all games an organizer is involved with
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerGames(organizer_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'organizer_id' is not null or undefined
		if (organizer_id === null || organizer_id === undefined) {
			throw new RequiredError(
				"organizer_id",
				"Required parameter organizer_id was null or undefined when calling getOrganizerGames.",
			);
		}
		const localVarPath = `/organizers/{organizer_id}/games`.replace(
			`{${"organizer_id"}}`,
			encodeURIComponent(String(organizer_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all hubs of an organizer
	 * @summary Retrieve all hubs of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerHubs(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'organizer_id' is not null or undefined
		if (organizer_id === null || organizer_id === undefined) {
			throw new RequiredError(
				"organizer_id",
				"Required parameter organizer_id was null or undefined when calling getOrganizerHubs.",
			);
		}
		const localVarPath = `/organizers/{organizer_id}/hubs`.replace(
			`{${"organizer_id"}}`,
			encodeURIComponent(String(organizer_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all tournaments of an organizer
	 * @summary Retrieve all tournaments of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {'past' | 'upcoming'} [type] Kind of tournament. Can be upcoming(default) or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerTournaments(
		organizer_id: string,
		type?: "past" | "upcoming",
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'organizer_id' is not null or undefined
		if (organizer_id === null || organizer_id === undefined) {
			throw new RequiredError(
				"organizer_id",
				"Required parameter organizer_id was null or undefined when calling getOrganizerTournaments.",
			);
		}
		const localVarPath = `/organizers/{organizer_id}/tournaments`.replace(
			`{${"organizer_id"}}`,
			encodeURIComponent(String(organizer_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (type !== undefined) {
			localVarQueryParameter["type"] = type;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * OrganizersApi - functional programming interface
 * @export
 */
export const OrganizersApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve organizer details
	 * @summary Retrieve organizer details
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizer(
		organizer_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Organizer> {
		const localVarFetchArgs = OrganizersApiFetchParamCreator(
			configuration,
		).getOrganizer(organizer_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve organizer details from name
	 * @summary Retrieve organizer details from name
	 * @param {string} name The name of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerByName(
		name: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Organizer> {
		const localVarFetchArgs = OrganizersApiFetchParamCreator(
			configuration,
		).getOrganizerByName(name, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all championships of an organizer
	 * @summary Retrieve all championships of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerChampionships(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<ChampionshipsList> {
		const localVarFetchArgs = OrganizersApiFetchParamCreator(
			configuration,
		).getOrganizerChampionships(organizer_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all games an organizer is involved with
	 * @summary Retrieve all games an organizer is involved with
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerGames(
		organizer_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<GamesList> {
		const localVarFetchArgs = OrganizersApiFetchParamCreator(
			configuration,
		).getOrganizerGames(organizer_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all hubs of an organizer
	 * @summary Retrieve all hubs of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerHubs(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<HubsList> {
		const localVarFetchArgs = OrganizersApiFetchParamCreator(
			configuration,
		).getOrganizerHubs(organizer_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all tournaments of an organizer
	 * @summary Retrieve all tournaments of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {'past' | 'upcoming'} [type] Kind of tournament. Can be upcoming(default) or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerTournaments(
		organizer_id: string,
		type?: "past" | "upcoming",
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentsList> {
		const localVarFetchArgs = OrganizersApiFetchParamCreator(
			configuration,
		).getOrganizerTournaments(organizer_id, type, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * OrganizersApi - factory interface
 * @export
 */
export const OrganizersApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve organizer details
	 * @summary Retrieve organizer details
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizer(organizer_id: string, options?: any) {
		return OrganizersApiFp(configuration).getOrganizer(organizer_id, options)(
			fetch,
			basePath,
		);
	},
	/**
	 * Retrieve organizer details from name
	 * @summary Retrieve organizer details from name
	 * @param {string} name The name of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerByName(name: string, options?: any) {
		return OrganizersApiFp(configuration).getOrganizerByName(name, options)(
			fetch,
			basePath,
		);
	},
	/**
	 * Retrieve all championships of an organizer
	 * @summary Retrieve all championships of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerChampionships(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return OrganizersApiFp(configuration).getOrganizerChampionships(
			organizer_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all games an organizer is involved with
	 * @summary Retrieve all games an organizer is involved with
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerGames(organizer_id: string, options?: any) {
		return OrganizersApiFp(configuration).getOrganizerGames(
			organizer_id,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all hubs of an organizer
	 * @summary Retrieve all hubs of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerHubs(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return OrganizersApiFp(configuration).getOrganizerHubs(
			organizer_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all tournaments of an organizer
	 * @summary Retrieve all tournaments of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {'past' | 'upcoming'} [type] Kind of tournament. Can be upcoming(default) or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrganizerTournaments(
		organizer_id: string,
		type?: "past" | "upcoming",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return OrganizersApiFp(configuration).getOrganizerTournaments(
			organizer_id,
			type,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * OrganizersApi - object-oriented interface
 * @export
 * @class OrganizersApi
 * @extends {BaseAPI}
 */
export class OrganizersApi extends BaseAPI {
	/**
	 * Retrieve organizer details
	 * @summary Retrieve organizer details
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrganizersApi
	 */
	public getOrganizer(organizer_id: string, options?: any) {
		return OrganizersApiFp(this.configuration).getOrganizer(
			organizer_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve organizer details from name
	 * @summary Retrieve organizer details from name
	 * @param {string} name The name of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrganizersApi
	 */
	public getOrganizerByName(name: string, options?: any) {
		return OrganizersApiFp(this.configuration).getOrganizerByName(
			name,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all championships of an organizer
	 * @summary Retrieve all championships of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrganizersApi
	 */
	public getOrganizerChampionships(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return OrganizersApiFp(this.configuration).getOrganizerChampionships(
			organizer_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all games an organizer is involved with
	 * @summary Retrieve all games an organizer is involved with
	 * @param {string} organizer_id The id of the organizer
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrganizersApi
	 */
	public getOrganizerGames(organizer_id: string, options?: any) {
		return OrganizersApiFp(this.configuration).getOrganizerGames(
			organizer_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all hubs of an organizer
	 * @summary Retrieve all hubs of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrganizersApi
	 */
	public getOrganizerHubs(
		organizer_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return OrganizersApiFp(this.configuration).getOrganizerHubs(
			organizer_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all tournaments of an organizer
	 * @summary Retrieve all tournaments of an organizer
	 * @param {string} organizer_id The id of the organizer
	 * @param {'past' | 'upcoming'} [type] Kind of tournament. Can be upcoming(default) or past
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrganizersApi
	 */
	public getOrganizerTournaments(
		organizer_id: string,
		type?: "past" | "upcoming",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return OrganizersApiFp(this.configuration).getOrganizerTournaments(
			organizer_id,
			type,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * PlayersApi - fetch parameter creator
 * @export
 */
export const PlayersApiFetchParamCreator = (configuration?: Configuration) => ({
	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayer(player_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayer.",
			);
		}
		const localVarPath = `/players/{player_id}`.replace(
			`{${"player_id"}}`,
			encodeURIComponent(String(player_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all bans of a player
	 * @summary Retrieve all bans of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerBans(
		player_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerBans.",
			);
		}
		const localVarPath = `/players/{player_id}/bans`.replace(
			`{${"player_id"}}`,
			encodeURIComponent(String(player_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} [nickname] The nickname of the player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [game_player_id] The ID of a player on game&#39;s platform
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerFromLookup(
		nickname?: string,
		game?: string,
		game_player_id?: string,
		options: any = {},
	): FetchArgs {
		const localVarPath = `/players`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (nickname !== undefined) {
			localVarQueryParameter["nickname"] = nickname;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (game_player_id !== undefined) {
			localVarQueryParameter["game_player_id"] = game_player_id;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all matches of a player
	 * @summary Retrieve all matches of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game A game on FACEIT
	 * @param {number} [from] The timestamp (Unix time) as lower bound of the query. 1 month ago if not specified
	 * @param {number} [to] The timestamp (Unix time) as higher bound of the query. Current timestamp if not specified
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerHistory(
		player_id: string,
		game: string,
		from?: number,
		to?: number,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerHistory.",
			);
		}
		// verify required parameter 'game' is not null or undefined
		if (game === null || game === undefined) {
			throw new RequiredError(
				"game",
				"Required parameter game was null or undefined when calling getPlayerHistory.",
			);
		}
		const localVarPath = `/players/{player_id}/history`.replace(
			`{${"player_id"}}`,
			encodeURIComponent(String(player_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (from !== undefined) {
			localVarQueryParameter["from"] = from;
		}

		if (to !== undefined) {
			localVarQueryParameter["to"] = to;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all hubs of a player
	 * @summary Retrieve all hubs of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerHubs(
		player_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerHubs.",
			);
		}
		const localVarPath = `/players/{player_id}/hubs`.replace(
			`{${"player_id"}}`,
			encodeURIComponent(String(player_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve statistics of a player for a given amount of matches
	 * @summary Retrieve statistics of a player for a given amount of matches
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {number} [from] Used to filter the dataset by date (minimum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {number} [to] Used to filter the dataset by date (maximum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerStats(
		player_id: string,
		game_id: string,
		offset?: number,
		limit?: number,
		from?: number,
		to?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerStats.",
			);
		}
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getPlayerStats.",
			);
		}
		const localVarPath = `/players/{player_id}/games/{game_id}/stats`
			.replace(`{${"player_id"}}`, encodeURIComponent(String(player_id)))
			.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		if (from !== undefined) {
			localVarQueryParameter["from"] = from;
		}

		if (to !== undefined) {
			localVarQueryParameter["to"] = to;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve statistics of a player
	 * @summary Retrieve statistics of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerStats_1(
		player_id: string,
		game_id: string,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerStats_1.",
			);
		}
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getPlayerStats_1.",
			);
		}
		const localVarPath = `/players/{player_id}/stats/{game_id}`
			.replace(`{${"player_id"}}`, encodeURIComponent(String(player_id)))
			.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all teams of a player
	 * @summary Retrieve all teams of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerTeams(
		player_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerTeams.",
			);
		}
		const localVarPath = `/players/{player_id}/teams`.replace(
			`{${"player_id"}}`,
			encodeURIComponent(String(player_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all tournaments of a player
	 * @summary Retrieve all tournaments of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerTournaments(
		player_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerTournaments.",
			);
		}
		const localVarPath = `/players/{player_id}/tournaments`.replace(
			`{${"player_id"}}`,
			encodeURIComponent(String(player_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayer(
		player_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayer(player_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all bans of a player
	 * @summary Retrieve all bans of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerBans(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerBansList> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerBans(player_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} [nickname] The nickname of the player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [game_player_id] The ID of a player on game&#39;s platform
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerFromLookup(
		nickname?: string,
		game?: string,
		game_player_id?: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerFromLookup(nickname, game, game_player_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all matches of a player
	 * @summary Retrieve all matches of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game A game on FACEIT
	 * @param {number} [from] The timestamp (Unix time) as lower bound of the query. 1 month ago if not specified
	 * @param {number} [to] The timestamp (Unix time) as higher bound of the query. Current timestamp if not specified
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerHistory(
		player_id: string,
		game: string,
		from?: number,
		to?: number,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<MatchHistoryList> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerHistory(player_id, game, from, to, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all hubs of a player
	 * @summary Retrieve all hubs of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerHubs(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<HubsList> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerHubs(player_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve statistics of a player for a given amount of matches
	 * @summary Retrieve statistics of a player for a given amount of matches
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {number} [from] Used to filter the dataset by date (minimum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {number} [to] Used to filter the dataset by date (maximum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerStats(
		player_id: string,
		game_id: string,
		offset?: number,
		limit?: number,
		from?: number,
		to?: number,
		options?: any,
	): (
		fetch?: FetchAPI,
		basePath?: string,
	) => Promise<PlayerStatsForMatchesList> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerStats(player_id, game_id, offset, limit, from, to, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve statistics of a player
	 * @summary Retrieve statistics of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerStats_1(
		player_id: string,
		game_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerStats> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerStats_1(player_id, game_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all teams of a player
	 * @summary Retrieve all teams of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerTeams(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TeamList> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerTeams(player_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all tournaments of a player
	 * @summary Retrieve all tournaments of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerTournaments(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentsList> {
		const localVarFetchArgs = PlayersApiFetchParamCreator(
			configuration,
		).getPlayerTournaments(player_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayer(player_id: string, options?: any) {
		return PlayersApiFp(configuration).getPlayer(player_id, options)(
			fetch,
			basePath,
		);
	},
	/**
	 * Retrieve all bans of a player
	 * @summary Retrieve all bans of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerBans(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(configuration).getPlayerBans(
			player_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} [nickname] The nickname of the player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [game_player_id] The ID of a player on game&#39;s platform
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerFromLookup(
		nickname?: string,
		game?: string,
		game_player_id?: string,
		options?: any,
	) {
		return PlayersApiFp(configuration).getPlayerFromLookup(
			nickname,
			game,
			game_player_id,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all matches of a player
	 * @summary Retrieve all matches of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game A game on FACEIT
	 * @param {number} [from] The timestamp (Unix time) as lower bound of the query. 1 month ago if not specified
	 * @param {number} [to] The timestamp (Unix time) as higher bound of the query. Current timestamp if not specified
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerHistory(
		player_id: string,
		game: string,
		from?: number,
		to?: number,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(configuration).getPlayerHistory(
			player_id,
			game,
			from,
			to,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all hubs of a player
	 * @summary Retrieve all hubs of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerHubs(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(configuration).getPlayerHubs(
			player_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve statistics of a player for a given amount of matches
	 * @summary Retrieve statistics of a player for a given amount of matches
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {number} [from] Used to filter the dataset by date (minimum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {number} [to] Used to filter the dataset by date (maximum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerStats(
		player_id: string,
		game_id: string,
		offset?: number,
		limit?: number,
		from?: number,
		to?: number,
		options?: any,
	) {
		return PlayersApiFp(configuration).getPlayerStats(
			player_id,
			game_id,
			offset,
			limit,
			from,
			to,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve statistics of a player
	 * @summary Retrieve statistics of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerStats_1(player_id: string, game_id: string, options?: any) {
		return PlayersApiFp(configuration).getPlayerStats_1(
			player_id,
			game_id,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all teams of a player
	 * @summary Retrieve all teams of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerTeams(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(configuration).getPlayerTeams(
			player_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all tournaments of a player
	 * @summary Retrieve all tournaments of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerTournaments(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(configuration).getPlayerTournaments(
			player_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} player_id The id of the player
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayer(player_id: string, options?: any) {
		return PlayersApiFp(this.configuration).getPlayer(player_id, options)(
			this.fetch,
			this.basePath,
		);
	}

	/**
	 * Retrieve all bans of a player
	 * @summary Retrieve all bans of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerBans(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(this.configuration).getPlayerBans(
			player_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve player details
	 * @summary Retrieve player details
	 * @param {string} [nickname] The nickname of the player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [game_player_id] The ID of a player on game&#39;s platform
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerFromLookup(
		nickname?: string,
		game?: string,
		game_player_id?: string,
		options?: any,
	) {
		return PlayersApiFp(this.configuration).getPlayerFromLookup(
			nickname,
			game,
			game_player_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all matches of a player
	 * @summary Retrieve all matches of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game A game on FACEIT
	 * @param {number} [from] The timestamp (Unix time) as lower bound of the query. 1 month ago if not specified
	 * @param {number} [to] The timestamp (Unix time) as higher bound of the query. Current timestamp if not specified
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerHistory(
		player_id: string,
		game: string,
		from?: number,
		to?: number,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(this.configuration).getPlayerHistory(
			player_id,
			game,
			from,
			to,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all hubs of a player
	 * @summary Retrieve all hubs of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerHubs(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(this.configuration).getPlayerHubs(
			player_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve statistics of a player for a given amount of matches
	 * @summary Retrieve statistics of a player for a given amount of matches
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {number} [from] Used to filter the dataset by date (minimum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {number} [to] Used to filter the dataset by date (maximum). Expected value is date (\&quot;items.stats.Match Finished At\&quot;) in epoch milliseconds.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerStats(
		player_id: string,
		game_id: string,
		offset?: number,
		limit?: number,
		from?: number,
		to?: number,
		options?: any,
	) {
		return PlayersApiFp(this.configuration).getPlayerStats(
			player_id,
			game_id,
			offset,
			limit,
			from,
			to,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve statistics of a player
	 * @summary Retrieve statistics of a player
	 * @param {string} player_id The id of the player
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerStats_1(player_id: string, game_id: string, options?: any) {
		return PlayersApiFp(this.configuration).getPlayerStats_1(
			player_id,
			game_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all teams of a player
	 * @summary Retrieve all teams of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerTeams(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(this.configuration).getPlayerTeams(
			player_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all tournaments of a player
	 * @summary Retrieve all tournaments of a player
	 * @param {string} player_id The id of the player
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlayersApi
	 */
	public getPlayerTournaments(
		player_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return PlayersApiFp(this.configuration).getPlayerTournaments(
			player_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * RankingsApi - fetch parameter creator
 * @export
 */
export const RankingsApiFetchParamCreator = (
	configuration?: Configuration,
) => ({
	/**
	 * Retrieve global ranking of a game
	 * @summary Retrieve global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGlobalRanking(
		game_id: string,
		region: string,
		country?: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getGlobalRanking.",
			);
		}
		// verify required parameter 'region' is not null or undefined
		if (region === null || region === undefined) {
			throw new RequiredError(
				"region",
				"Required parameter region was null or undefined when calling getGlobalRanking.",
			);
		}
		const localVarPath = `/rankings/games/{game_id}/regions/{region}`
			.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)))
			.replace(`{${"region"}}`, encodeURIComponent(String(region)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (country !== undefined) {
			localVarQueryParameter["country"] = country;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve user position in the global ranking of a game
	 * @summary Retrieve user position in the global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} player_id The id of a player
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerRanking(
		game_id: string,
		region: string,
		player_id: string,
		country?: string,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getPlayerRanking.",
			);
		}
		// verify required parameter 'region' is not null or undefined
		if (region === null || region === undefined) {
			throw new RequiredError(
				"region",
				"Required parameter region was null or undefined when calling getPlayerRanking.",
			);
		}
		// verify required parameter 'player_id' is not null or undefined
		if (player_id === null || player_id === undefined) {
			throw new RequiredError(
				"player_id",
				"Required parameter player_id was null or undefined when calling getPlayerRanking.",
			);
		}
		const localVarPath =
			`/rankings/games/{game_id}/regions/{region}/players/{player_id}`
				.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)))
				.replace(`{${"region"}}`, encodeURIComponent(String(region)))
				.replace(`{${"player_id"}}`, encodeURIComponent(String(player_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (country !== undefined) {
			localVarQueryParameter["country"] = country;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * RankingsApi - functional programming interface
 * @export
 */
export const RankingsApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve global ranking of a game
	 * @summary Retrieve global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGlobalRanking(
		game_id: string,
		region: string,
		country?: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<GlobalRankingList> {
		const localVarFetchArgs = RankingsApiFetchParamCreator(
			configuration,
		).getGlobalRanking(game_id, region, country, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve user position in the global ranking of a game
	 * @summary Retrieve user position in the global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} player_id The id of a player
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerRanking(
		game_id: string,
		region: string,
		player_id: string,
		country?: string,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerGlobalRanking> {
		const localVarFetchArgs = RankingsApiFetchParamCreator(
			configuration,
		).getPlayerRanking(game_id, region, player_id, country, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * RankingsApi - factory interface
 * @export
 */
export const RankingsApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve global ranking of a game
	 * @summary Retrieve global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getGlobalRanking(
		game_id: string,
		region: string,
		country?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return RankingsApiFp(configuration).getGlobalRanking(
			game_id,
			region,
			country,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve user position in the global ranking of a game
	 * @summary Retrieve user position in the global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} player_id The id of a player
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPlayerRanking(
		game_id: string,
		region: string,
		player_id: string,
		country?: string,
		limit?: number,
		options?: any,
	) {
		return RankingsApiFp(configuration).getPlayerRanking(
			game_id,
			region,
			player_id,
			country,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * RankingsApi - object-oriented interface
 * @export
 * @class RankingsApi
 * @extends {BaseAPI}
 */
export class RankingsApi extends BaseAPI {
	/**
	 * Retrieve global ranking of a game
	 * @summary Retrieve global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RankingsApi
	 */
	public getGlobalRanking(
		game_id: string,
		region: string,
		country?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return RankingsApiFp(this.configuration).getGlobalRanking(
			game_id,
			region,
			country,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve user position in the global ranking of a game
	 * @summary Retrieve user position in the global ranking of a game
	 * @param {string} game_id The id of the game
	 * @param {string} region A region of a game
	 * @param {string} player_id The id of a player
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RankingsApi
	 */
	public getPlayerRanking(
		game_id: string,
		region: string,
		player_id: string,
		country?: string,
		limit?: number,
		options?: any,
	) {
		return RankingsApiFp(this.configuration).getPlayerRanking(
			game_id,
			region,
			player_id,
			country,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = (configuration?: Configuration) => ({
	/**
	 * Search for championships
	 * @summary Search for championships
	 * @param {string} name The name of a championship on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchChampionships(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new RequiredError(
				"name",
				"Required parameter name was null or undefined when calling searchChampionships.",
			);
		}
		const localVarPath = `/search/championships`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (name !== undefined) {
			localVarQueryParameter["name"] = name;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (region !== undefined) {
			localVarQueryParameter["region"] = region;
		}

		if (type !== undefined) {
			localVarQueryParameter["type"] = type;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Search for clans
	 * @summary Search for clans
	 * @param {string} name The name of a clan on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchClans(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new RequiredError(
				"name",
				"Required parameter name was null or undefined when calling searchClans.",
			);
		}
		const localVarPath = `/search/clans`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (name !== undefined) {
			localVarQueryParameter["name"] = name;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (region !== undefined) {
			localVarQueryParameter["region"] = region;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Search for hubs
	 * @summary Search for hubs
	 * @param {string} name The name of a hub on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchHubs(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new RequiredError(
				"name",
				"Required parameter name was null or undefined when calling searchHubs.",
			);
		}
		const localVarPath = `/search/hubs`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (name !== undefined) {
			localVarQueryParameter["name"] = name;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (region !== undefined) {
			localVarQueryParameter["region"] = region;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Search for organizers
	 * @summary Search for organizers
	 * @param {string} name The name of a organizer on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchOrganizers(
		name: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new RequiredError(
				"name",
				"Required parameter name was null or undefined when calling searchOrganizers.",
			);
		}
		const localVarPath = `/search/organizers`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (name !== undefined) {
			localVarQueryParameter["name"] = name;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Search for players
	 * @summary Search for players
	 * @param {string} nickname The nickname of a player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchPlayers(
		nickname: string,
		game?: string,
		country?: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'nickname' is not null or undefined
		if (nickname === null || nickname === undefined) {
			throw new RequiredError(
				"nickname",
				"Required parameter nickname was null or undefined when calling searchPlayers.",
			);
		}
		const localVarPath = `/search/players`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (nickname !== undefined) {
			localVarQueryParameter["nickname"] = nickname;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (country !== undefined) {
			localVarQueryParameter["country"] = country;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Search for teams
	 * @summary Search for teams
	 * @param {string} nickname The nickname of a team on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchTeams(
		nickname: string,
		game?: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'nickname' is not null or undefined
		if (nickname === null || nickname === undefined) {
			throw new RequiredError(
				"nickname",
				"Required parameter nickname was null or undefined when calling searchTeams.",
			);
		}
		const localVarPath = `/search/teams`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (nickname !== undefined) {
			localVarQueryParameter["nickname"] = nickname;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Search for tournaments
	 * @summary Search for tournaments
	 * @param {string} name The name of a tournament on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchTournaments(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new RequiredError(
				"name",
				"Required parameter name was null or undefined when calling searchTournaments.",
			);
		}
		const localVarPath = `/search/tournaments`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (name !== undefined) {
			localVarQueryParameter["name"] = name;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (region !== undefined) {
			localVarQueryParameter["region"] = region;
		}

		if (type !== undefined) {
			localVarQueryParameter["type"] = type;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = (configuration?: Configuration) => ({
	/**
	 * Search for championships
	 * @summary Search for championships
	 * @param {string} name The name of a championship on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchChampionships(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsSearchList> {
		const localVarFetchArgs = SearchApiFetchParamCreator(
			configuration,
		).searchChampionships(name, game, region, type, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Search for clans
	 * @summary Search for clans
	 * @param {string} name The name of a clan on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchClans(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<ClansSearchList> {
		const localVarFetchArgs = SearchApiFetchParamCreator(
			configuration,
		).searchClans(name, game, region, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Search for hubs
	 * @summary Search for hubs
	 * @param {string} name The name of a hub on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchHubs(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsSearchList> {
		const localVarFetchArgs = SearchApiFetchParamCreator(
			configuration,
		).searchHubs(name, game, region, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Search for organizers
	 * @summary Search for organizers
	 * @param {string} name The name of a organizer on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchOrganizers(
		name: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizersSearchList> {
		const localVarFetchArgs = SearchApiFetchParamCreator(
			configuration,
		).searchOrganizers(name, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Search for players
	 * @summary Search for players
	 * @param {string} nickname The nickname of a player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchPlayers(
		nickname: string,
		game?: string,
		country?: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<UsersSearchList> {
		const localVarFetchArgs = SearchApiFetchParamCreator(
			configuration,
		).searchPlayers(nickname, game, country, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Search for teams
	 * @summary Search for teams
	 * @param {string} nickname The nickname of a team on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchTeams(
		nickname: string,
		game?: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TeamsSearchList> {
		const localVarFetchArgs = SearchApiFetchParamCreator(
			configuration,
		).searchTeams(nickname, game, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Search for tournaments
	 * @summary Search for tournaments
	 * @param {string} name The name of a tournament on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchTournaments(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsSearchList> {
		const localVarFetchArgs = SearchApiFetchParamCreator(
			configuration,
		).searchTournaments(name, game, region, type, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Search for championships
	 * @summary Search for championships
	 * @param {string} name The name of a championship on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchChampionships(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(configuration).searchChampionships(
			name,
			game,
			region,
			type,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Search for clans
	 * @summary Search for clans
	 * @param {string} name The name of a clan on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchClans(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(configuration).searchClans(
			name,
			game,
			region,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Search for hubs
	 * @summary Search for hubs
	 * @param {string} name The name of a hub on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchHubs(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(configuration).searchHubs(
			name,
			game,
			region,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Search for organizers
	 * @summary Search for organizers
	 * @param {string} name The name of a organizer on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchOrganizers(
		name: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(configuration).searchOrganizers(
			name,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Search for players
	 * @summary Search for players
	 * @param {string} nickname The nickname of a player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchPlayers(
		nickname: string,
		game?: string,
		country?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(configuration).searchPlayers(
			nickname,
			game,
			country,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Search for teams
	 * @summary Search for teams
	 * @param {string} nickname The nickname of a team on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchTeams(
		nickname: string,
		game?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(configuration).searchTeams(
			nickname,
			game,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Search for tournaments
	 * @summary Search for tournaments
	 * @param {string} name The name of a tournament on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	searchTournaments(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(configuration).searchTournaments(
			name,
			game,
			region,
			type,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
	/**
	 * Search for championships
	 * @summary Search for championships
	 * @param {string} name The name of a championship on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SearchApi
	 */
	public searchChampionships(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(this.configuration).searchChampionships(
			name,
			game,
			region,
			type,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Search for clans
	 * @summary Search for clans
	 * @param {string} name The name of a clan on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SearchApi
	 */
	public searchClans(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(this.configuration).searchClans(
			name,
			game,
			region,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Search for hubs
	 * @summary Search for hubs
	 * @param {string} name The name of a hub on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SearchApi
	 */
	public searchHubs(
		name: string,
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(this.configuration).searchHubs(
			name,
			game,
			region,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Search for organizers
	 * @summary Search for organizers
	 * @param {string} name The name of a organizer on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SearchApi
	 */
	public searchOrganizers(
		name: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(this.configuration).searchOrganizers(
			name,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Search for players
	 * @summary Search for players
	 * @param {string} nickname The nickname of a player on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [country] A country code (ISO 3166-1)
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SearchApi
	 */
	public searchPlayers(
		nickname: string,
		game?: string,
		country?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(this.configuration).searchPlayers(
			nickname,
			game,
			country,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Search for teams
	 * @summary Search for teams
	 * @param {string} nickname The nickname of a team on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SearchApi
	 */
	public searchTeams(
		nickname: string,
		game?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(this.configuration).searchTeams(
			nickname,
			game,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Search for tournaments
	 * @summary Search for tournaments
	 * @param {string} name The name of a tournament on FACEIT
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {'all' | 'upcoming' | 'ongoing' | 'past'} [type] Kind of competitions to return
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SearchApi
	 */
	public searchTournaments(
		name: string,
		game?: string,
		region?: string,
		type?: "all" | "upcoming" | "ongoing" | "past",
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return SearchApiFp(this.configuration).searchTournaments(
			name,
			game,
			region,
			type,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * TeamsApi - fetch parameter creator
 * @export
 */
export const TeamsApiFetchParamCreator = (configuration?: Configuration) => ({
	/**
	 * Retrieve team details
	 * @summary Retrieve team details
	 * @param {string} team_id The id of the team
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeam(team_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'team_id' is not null or undefined
		if (team_id === null || team_id === undefined) {
			throw new RequiredError(
				"team_id",
				"Required parameter team_id was null or undefined when calling getTeam.",
			);
		}
		const localVarPath = `/teams/{team_id}`.replace(
			`{${"team_id"}}`,
			encodeURIComponent(String(team_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve statistics of a team
	 * @summary Retrieve statistics of a team
	 * @param {string} team_id The id of the team
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeamStats(team_id: string, game_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'team_id' is not null or undefined
		if (team_id === null || team_id === undefined) {
			throw new RequiredError(
				"team_id",
				"Required parameter team_id was null or undefined when calling getTeamStats.",
			);
		}
		// verify required parameter 'game_id' is not null or undefined
		if (game_id === null || game_id === undefined) {
			throw new RequiredError(
				"game_id",
				"Required parameter game_id was null or undefined when calling getTeamStats.",
			);
		}
		const localVarPath = `/teams/{team_id}/stats/{game_id}`
			.replace(`{${"team_id"}}`, encodeURIComponent(String(team_id)))
			.replace(`{${"game_id"}}`, encodeURIComponent(String(game_id)));
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve tournaments of a team
	 * @summary Retrieve tournaments of a team
	 * @param {string} team_id The id of the team
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeamTournaments(
		team_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'team_id' is not null or undefined
		if (team_id === null || team_id === undefined) {
			throw new RequiredError(
				"team_id",
				"Required parameter team_id was null or undefined when calling getTeamTournaments.",
			);
		}
		const localVarPath = `/teams/{team_id}/tournaments`.replace(
			`{${"team_id"}}`,
			encodeURIComponent(String(team_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve team details
	 * @summary Retrieve team details
	 * @param {string} team_id The id of the team
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeam(
		team_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
		const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).getTeam(
			team_id,
			options,
		);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve statistics of a team
	 * @summary Retrieve statistics of a team
	 * @param {string} team_id The id of the team
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeamStats(
		team_id: string,
		game_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TeamStats> {
		const localVarFetchArgs = TeamsApiFetchParamCreator(
			configuration,
		).getTeamStats(team_id, game_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve tournaments of a team
	 * @summary Retrieve tournaments of a team
	 * @param {string} team_id The id of the team
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeamTournaments(
		team_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentsList> {
		const localVarFetchArgs = TeamsApiFetchParamCreator(
			configuration,
		).getTeamTournaments(team_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve team details
	 * @summary Retrieve team details
	 * @param {string} team_id The id of the team
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeam(team_id: string, options?: any) {
		return TeamsApiFp(configuration).getTeam(team_id, options)(fetch, basePath);
	},
	/**
	 * Retrieve statistics of a team
	 * @summary Retrieve statistics of a team
	 * @param {string} team_id The id of the team
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeamStats(team_id: string, game_id: string, options?: any) {
		return TeamsApiFp(configuration).getTeamStats(
			team_id,
			game_id,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve tournaments of a team
	 * @summary Retrieve tournaments of a team
	 * @param {string} team_id The id of the team
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTeamTournaments(
		team_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TeamsApiFp(configuration).getTeamTournaments(
			team_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
	/**
	 * Retrieve team details
	 * @summary Retrieve team details
	 * @param {string} team_id The id of the team
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamsApi
	 */
	public getTeam(team_id: string, options?: any) {
		return TeamsApiFp(this.configuration).getTeam(team_id, options)(
			this.fetch,
			this.basePath,
		);
	}

	/**
	 * Retrieve statistics of a team
	 * @summary Retrieve statistics of a team
	 * @param {string} team_id The id of the team
	 * @param {string} game_id A game on FACEIT
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamsApi
	 */
	public getTeamStats(team_id: string, game_id: string, options?: any) {
		return TeamsApiFp(this.configuration).getTeamStats(
			team_id,
			game_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve tournaments of a team
	 * @summary Retrieve tournaments of a team
	 * @param {string} team_id The id of the team
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamsApi
	 */
	public getTeamTournaments(
		team_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TeamsApiFp(this.configuration).getTeamTournaments(
			team_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}

/**
 * TournamentsApi - fetch parameter creator
 * @export
 */
export const TournamentsApiFetchParamCreator = (
	configuration?: Configuration,
) => ({
	/**
	 * Retrieve tournament details
	 * @summary Retrieve tournament details
	 * @param {string} tournament_id The id of the tournament
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournament(
		tournament_id: string,
		expanded?: Array<"organizer" | "game">,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'tournament_id' is not null or undefined
		if (tournament_id === null || tournament_id === undefined) {
			throw new RequiredError(
				"tournament_id",
				"Required parameter tournament_id was null or undefined when calling getTournament.",
			);
		}
		const localVarPath = `/tournaments/{tournament_id}`.replace(
			`{${"tournament_id"}}`,
			encodeURIComponent(String(tournament_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (expanded) {
			localVarQueryParameter["expanded"] = expanded.join(
				COLLECTION_FORMATS["csv"],
			);
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve brackets of a tournament
	 * @summary Retrieve brackets of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentBrackets(tournament_id: string, options: any = {}): FetchArgs {
		// verify required parameter 'tournament_id' is not null or undefined
		if (tournament_id === null || tournament_id === undefined) {
			throw new RequiredError(
				"tournament_id",
				"Required parameter tournament_id was null or undefined when calling getTournamentBrackets.",
			);
		}
		const localVarPath = `/tournaments/{tournament_id}/brackets`.replace(
			`{${"tournament_id"}}`,
			encodeURIComponent(String(tournament_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all matches of a tournament
	 * @summary Retrieve all matches of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentMatches(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'tournament_id' is not null or undefined
		if (tournament_id === null || tournament_id === undefined) {
			throw new RequiredError(
				"tournament_id",
				"Required parameter tournament_id was null or undefined when calling getTournamentMatches.",
			);
		}
		const localVarPath = `/tournaments/{tournament_id}/matches`.replace(
			`{${"tournament_id"}}`,
			encodeURIComponent(String(tournament_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve all teams of a tournament
	 * @summary Retrieve all teams of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentTeams(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		// verify required parameter 'tournament_id' is not null or undefined
		if (tournament_id === null || tournament_id === undefined) {
			throw new RequiredError(
				"tournament_id",
				"Required parameter tournament_id was null or undefined when calling getTournamentTeams.",
			);
		}
		const localVarPath = `/tournaments/{tournament_id}/teams`.replace(
			`{${"tournament_id"}}`,
			encodeURIComponent(String(tournament_id)),
		);
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
	/**
	 * Retrieve tournaments v1 (no longer used). Please refer to the Championships controller to retrieve tournaments v2
	 * @summary Retrieve tournaments v1 (no longer used)
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentsList(
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options: any = {},
	): FetchArgs {
		const localVarPath = `/tournaments`;
		const localVarUrlObj = url.parse(localVarPath, true);
		const localVarRequestOptions = Object.assign({ method: "GET" }, options);
		const localVarHeaderParameter = {} as any;
		const localVarQueryParameter = {} as any;

		// authentication key required
		if (configuration && configuration.apiKey) {
			const localVarApiKeyValue =
				typeof configuration.apiKey === "function"
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
			localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
		}

		if (game !== undefined) {
			localVarQueryParameter["game"] = game;
		}

		if (region !== undefined) {
			localVarQueryParameter["region"] = region;
		}

		if (offset !== undefined) {
			localVarQueryParameter["offset"] = offset;
		}

		if (limit !== undefined) {
			localVarQueryParameter["limit"] = limit;
		}

		localVarUrlObj.query = Object.assign(
			{},
			localVarUrlObj.query,
			localVarQueryParameter,
			options.query,
		);
		// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
		localVarUrlObj.search = null;
		localVarRequestOptions.headers = Object.assign(
			{},
			localVarHeaderParameter,
			options.headers,
		);

		return {
			url: url.format(localVarUrlObj),
			options: localVarRequestOptions,
		};
	},
});

/**
 * TournamentsApi - functional programming interface
 * @export
 */
export const TournamentsApiFp = (configuration?: Configuration) => ({
	/**
	 * Retrieve tournament details
	 * @summary Retrieve tournament details
	 * @param {string} tournament_id The id of the tournament
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournament(
		tournament_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Tournament> {
		const localVarFetchArgs = TournamentsApiFetchParamCreator(
			configuration,
		).getTournament(tournament_id, expanded, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve brackets of a tournament
	 * @summary Retrieve brackets of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentBrackets(
		tournament_id: string,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<Brackets> {
		const localVarFetchArgs = TournamentsApiFetchParamCreator(
			configuration,
		).getTournamentBrackets(tournament_id, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all matches of a tournament
	 * @summary Retrieve all matches of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentMatches(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<MatchList> {
		const localVarFetchArgs = TournamentsApiFetchParamCreator(
			configuration,
		).getTournamentMatches(tournament_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve all teams of a tournament
	 * @summary Retrieve all teams of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentTeams(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentTeams> {
		const localVarFetchArgs = TournamentsApiFetchParamCreator(
			configuration,
		).getTournamentTeams(tournament_id, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
	/**
	 * Retrieve tournaments v1 (no longer used). Please refer to the Championships controller to retrieve tournaments v2
	 * @summary Retrieve tournaments v1 (no longer used)
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentsList(
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentsList> {
		const localVarFetchArgs = TournamentsApiFetchParamCreator(
			configuration,
		).getTournamentsList(game, region, offset, limit, options);
		return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
			return fetch(
				basePath + localVarFetchArgs.url,
				localVarFetchArgs.options,
			).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					throw response;
				}
			});
		};
	},
});

/**
 * TournamentsApi - factory interface
 * @export
 */
export const TournamentsApiFactory = (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string,
) => ({
	/**
	 * Retrieve tournament details
	 * @summary Retrieve tournament details
	 * @param {string} tournament_id The id of the tournament
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournament(
		tournament_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	) {
		return TournamentsApiFp(configuration).getTournament(
			tournament_id,
			expanded,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve brackets of a tournament
	 * @summary Retrieve brackets of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentBrackets(tournament_id: string, options?: any) {
		return TournamentsApiFp(configuration).getTournamentBrackets(
			tournament_id,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all matches of a tournament
	 * @summary Retrieve all matches of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentMatches(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TournamentsApiFp(configuration).getTournamentMatches(
			tournament_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve all teams of a tournament
	 * @summary Retrieve all teams of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentTeams(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TournamentsApiFp(configuration).getTournamentTeams(
			tournament_id,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
	/**
	 * Retrieve tournaments v1 (no longer used). Please refer to the Championships controller to retrieve tournaments v2
	 * @summary Retrieve tournaments v1 (no longer used)
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getTournamentsList(
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TournamentsApiFp(configuration).getTournamentsList(
			game,
			region,
			offset,
			limit,
			options,
		)(fetch, basePath);
	},
});

/**
 * TournamentsApi - object-oriented interface
 * @export
 * @class TournamentsApi
 * @extends {BaseAPI}
 */
export class TournamentsApi extends BaseAPI {
	/**
	 * Retrieve tournament details
	 * @summary Retrieve tournament details
	 * @param {string} tournament_id The id of the tournament
	 * @param {Array<'organizer' | 'game'>} [expanded] List of entity names to expand in request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TournamentsApi
	 */
	public getTournament(
		tournament_id: string,
		expanded?: Array<"organizer" | "game">,
		options?: any,
	) {
		return TournamentsApiFp(this.configuration).getTournament(
			tournament_id,
			expanded,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve brackets of a tournament
	 * @summary Retrieve brackets of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TournamentsApi
	 */
	public getTournamentBrackets(tournament_id: string, options?: any) {
		return TournamentsApiFp(this.configuration).getTournamentBrackets(
			tournament_id,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all matches of a tournament
	 * @summary Retrieve all matches of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TournamentsApi
	 */
	public getTournamentMatches(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TournamentsApiFp(this.configuration).getTournamentMatches(
			tournament_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve all teams of a tournament
	 * @summary Retrieve all teams of a tournament
	 * @param {string} tournament_id The id of the tournament
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TournamentsApi
	 */
	public getTournamentTeams(
		tournament_id: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TournamentsApiFp(this.configuration).getTournamentTeams(
			tournament_id,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}

	/**
	 * Retrieve tournaments v1 (no longer used). Please refer to the Championships controller to retrieve tournaments v2
	 * @summary Retrieve tournaments v1 (no longer used)
	 * @param {string} [game] A game on FACEIT
	 * @param {string} [region] A region of the game
	 * @param {number} [offset] The starting item position
	 * @param {number} [limit] The number of items to return
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TournamentsApi
	 */
	public getTournamentsList(
		game?: string,
		region?: string,
		offset?: number,
		limit?: number,
		options?: any,
	) {
		return TournamentsApiFp(this.configuration).getTournamentsList(
			game,
			region,
			offset,
			limit,
			options,
		)(this.fetch, this.basePath);
	}
}
